<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Between pages...</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier Prime', 'Courier New', Courier, monospace;
      background-color: #faf8f5;
      color: #3d3428;
      min-height: 100vh;
      letter-spacing: 0.5px;
    }

    .container {
      max-width: 480px;
      margin: 0 auto;
      min-height: 100vh;
    }

    /* Views */
    .view {
      display: none;
      min-height: 100vh;
    }

    .view.active {
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      padding: 16px 20px;
      background: #faf8f5;
      border-bottom: 1px solid #e8e4df;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .header-title {
      font-size: 14px;
      font-weight: 400;
      letter-spacing: 2px;
      text-transform: lowercase;
      color: #5c4d3d;
    }

    .back-btn {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      padding: 4px 8px;
      color: #5c4d3d;
    }

    /* Sticky Header (Home) - Slim Horizontal */
    .sticky-header {
      padding: 14px 20px;
      background: #faf8f5;
      position: sticky;
      top: 0;
      z-index: 40;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid #ebe7e2;
    }

    .logo-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .header-divider {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 1px;
      height: 28px;
      background: #ddd6cc;
    }

    .logo-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      width: 24px;
      height: 28px;
    }

    .logo-icon::before,
    .logo-icon::after {
      content: '';
      width: 2px;
      height: 22px;
      background: linear-gradient(to bottom, transparent, #8b7355 20%, #8b7355 80%, transparent);
      border-radius: 1px;
    }

    .logo-icon::after {
      background: linear-gradient(to bottom, transparent, #a89078 20%, #a89078 80%, transparent);
    }

    .sticky-header h1 {
      font-size: 14px;
      font-weight: 400;
      letter-spacing: 4px;
      color: #5c4d3d;
      text-transform: lowercase;
      display: flex;
      flex-direction: column;
      line-height: 1.3;
    }

    .sticky-header h1 span {
      display: block;
    }

    .tagline {
      font-size: 8.5px;
      color: #b8a99a;
      letter-spacing: 1px;
      font-style: italic;
      white-space: nowrap;
      padding-left: 20px;
    }

    /* Empty State */
    .empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 40px;
      text-align: center;
    }

    .empty-state h2 {
      font-size: 18px;
      font-weight: 400;
      letter-spacing: 2px;
      margin-bottom: 12px;
      color: #5c4d3d;
    }

    .empty-state p {
      font-size: 13px;
      color: #a89078;
      letter-spacing: 1px;
    }

    /* Timeline / Year Sections */
    .timeline {
      flex: 1;
      padding: 0 20px 100px;
      overflow-y: auto;
      background: #faf8f5;
    }

    .year-header {
      display: flex;
      align-items: center;
      margin: 28px 0 20px;
    }

    .year-line {
      flex: 1;
      height: 1px;
      background: #d4cec4;
    }

    .year-text {
      font-size: 16px;
      letter-spacing: 4px;
      margin: 0 16px;
      color: #8b7355;
    }

    /* Floating year indicator */
    .year-indicator {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%) translateY(-10px);
      background: rgba(212, 206, 196, 0.85);
      color: #fff;
      padding: 6px 16px;
      border-radius: 20px;
      font-size: 14px;
      letter-spacing: 3px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease, transform 0.3s ease;
      z-index: 50;
    }

    .year-indicator.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    /* Book Grid */
    .year-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      justify-content: space-between;
    }

    .book-card {
      width: calc(50% - 8px);
      cursor: pointer;
      margin-bottom: 12px;
      transition: transform 0.2s;
    }

    .book-card:hover {
      transform: translateY(-2px);
    }

    .card-inner {
      position: relative;
      box-shadow: 0 2px 8px rgba(92, 77, 61, 0.1);
    }

    .card-cover {
      width: 100%;
      aspect-ratio: 2 / 3;
      background: #e8e4df;
      object-fit: cover;
      display: block;
    }

    .card-title {
      margin-top: 10px;
      font-size: 12px;
      letter-spacing: 0.5px;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      color: #3d3428;
    }

    .card-author {
      font-size: 10px;
      color: #8b7355;
      margin-top: 2px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* FAB Button */
    .fab {
      position: fixed;
      bottom: 36px;
      right: 24px;
      width: 56px;
      height: 56px;
      background: #5c4d3d;
      color: #faf8f5;
      border: none;
      font-size: 28px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: inherit;
      z-index: 50;
      border-radius: 50%;
      box-shadow: 0 4px 16px rgba(92, 77, 61, 0.3);
      transition: all 0.2s;
    }

    .fab:hover {
      background: #4a3e31;
      transform: scale(1.05);
    }

    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 1px solid #e8e4df;
      background: #faf8f5;
    }

    .tab {
      flex: 1;
      padding: 14px;
      border: none;
      background: transparent;
      font-family: inherit;
      font-size: 13px;
      letter-spacing: 2px;
      cursor: pointer;
      color: #a89078;
      text-transform: lowercase;
      transition: all 0.2s;
    }

    .tab.active {
      background: #5c4d3d;
      color: #faf8f5;
    }

    .tab:not(.active):hover {
      color: #5c4d3d;
    }

    /* Tab Content */
    .tab-content {
      display: none;
      flex: 1;
      flex-direction: column;
    }

    .tab-content.active {
      display: flex;
    }

    /* Search */
    .search-row {
      display: flex;
      padding: 20px;
      gap: 12px;
      background: #faf8f5;
    }

    .search-input {
      flex: 1;
      font-family: inherit;
      background: #fff;
      padding: 14px 16px;
      font-size: 14px;
      border: 1px solid #e8e4df;
      outline: none;
      color: #5c4d3d;
    }

    .search-input::placeholder {
      color: #c4b8a8;
    }

    .search-input:focus {
      border-color: #a89078;
    }

    .search-btn {
      background: #5c4d3d;
      color: #faf8f5;
      border: none;
      padding: 14px 20px;
      font-family: inherit;
      font-size: 14px;
      letter-spacing: 1px;
      cursor: pointer;
      text-transform: lowercase;
    }

    .search-btn:hover {
      background: #4a3e31;
    }

    /* Search Results */
    .search-results {
      flex: 1;
      padding: 0 20px 20px;
      overflow-y: auto;
      background: #faf8f5;
    }

    .result-item {
      display: flex;
      border-bottom: 1px solid #e8e4df;
      padding: 14px 0;
      cursor: pointer;
      transition: background 0.2s;
    }

    .result-item:hover {
      background: #f5f0ea;
    }

    .result-cover {
      width: 50px;
      height: 75px;
      background: #e8e4df;
      object-fit: cover;
    }

    .result-info {
      flex: 1;
      margin-left: 14px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .result-title {
      font-size: 13px;
      margin-bottom: 6px;
      color: #3d3428;
    }

    .result-author {
      font-size: 11px;
      color: #8b7355;
    }

    .search-message {
      text-align: center;
      padding: 40px 20px;
      color: #a89078;
      font-size: 13px;
      letter-spacing: 1px;
    }

    /* Form */
    .form {
      padding: 24px;
      flex: 1;
      overflow-y: auto;
      background: #faf8f5;
    }

    .form-input {
      width: 100%;
      font-family: inherit;
      background: #fff;
      padding: 14px 16px;
      font-size: 14px;
      border: 1px solid #e8e4df;
      outline: none;
      margin-bottom: 16px;
      color: #5c4d3d;
    }

    .form-input::placeholder {
      color: #c4b8a8;
    }

    .form-input:focus {
      border-color: #a89078;
    }

    /* Cover Section */
    .cover-section {
      margin: 20px 0;
    }

    .cover-label {
      font-size: 12px;
      color: #8b7355;
      letter-spacing: 1px;
      margin-bottom: 12px;
      display: block;
    }

    .cover-options {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .cover-picker {
      flex-shrink: 0;
    }

    .cover-preview {
      width: 80px;
      height: 120px;
      object-fit: cover;
      border-radius: 2px;
    }

    .cover-placeholder {
      width: 80px;
      height: 120px;
      background: #fff;
      border: 1px dashed #c4b8a8;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      color: #a89078;
      cursor: pointer;
      border-radius: 2px;
      transition: all 0.2s ease;
    }

    .cover-placeholder-icon {
      font-size: 24px;
      line-height: 1;
      margin-bottom: 4px;
    }

    .cover-placeholder-text {
      font-size: 10px;
      letter-spacing: 1px;
    }

    .cover-placeholder:hover {
      border-color: #8b7355;
      color: #8b7355;
      background: #faf8f5;
    }

    .cover-url-section {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .cover-or {
      font-size: 11px;
      color: #b8a99a;
      font-style: italic;
    }

    .cover-url-input {
      flex: 1;
      margin-bottom: 0;
      font-size: 12px;
      padding: 10px 12px;
    }

    #cover-input {
      display: none;
    }

    /* Submit Button */
    .save-btn {
      width: 100%;
      background: #5c4d3d;
      color: #faf8f5;
      border: none;
      padding: 16px;
      font-family: inherit;
      font-size: 14px;
      letter-spacing: 2px;
      cursor: pointer;
      margin-top: 20px;
      text-transform: lowercase;
    }

    .save-btn:hover {
      background: #4a3e31;
    }

    /* Edit View - Story-Style Editor */
    .edit-view-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: #000;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 70;
    }

    .edit-cover-wrap {
      flex: 1;
      position: relative;
      overflow: hidden;
      background: #000;
    }

    .edit-cover-bg {
      position: absolute;
      top: -20px;
      left: -20px;
      right: -20px;
      bottom: -20px;
      background-size: cover;
      background-position: center;
      filter: blur(20px) brightness(0.4);
      z-index: 1;
    }

    .edit-cover {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: 100%;
      object-fit: contain;
      z-index: 2;
    }

    /* Trash icon for deleting text box */
    .edit-trash {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      width: 44px;
      height: 44px;
      background: rgba(0,0,0,0.4);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 18;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, transform 0.2s, background 0.2s;
    }

    .edit-trash.visible {
      opacity: 1;
      visibility: visible;
    }

    .edit-trash.active {
      background: rgba(200, 80, 80, 0.8);
      transform: translateX(-50%) scale(1.2);
    }

    .edit-trash::before {
      content: '';
      width: 18px;
      height: 20px;
      border: 2px solid #fff;
      border-top: none;
      border-radius: 0 0 4px 4px;
      position: relative;
    }

    .edit-trash::after {
      content: '';
      position: absolute;
      top: 10px;
      width: 22px;
      height: 3px;
      background: #fff;
      border-radius: 2px;
    }

    /* Save button for Edit View */
    .edit-save-btn {
      position: absolute;
      bottom: 32px;
      left: 50%;
      transform: translateX(-50%);
      background: #5c4d3d;
      color: #faf8f5;
      border: none;
      padding: 14px 48px;
      font-family: inherit;
      font-size: 14px;
      letter-spacing: 2px;
      cursor: pointer;
      text-transform: lowercase;
      z-index: 20;
    }

    .edit-save-btn:hover {
      background: #4a3e31;
    }

    /* Color Picker Toolbar */
    .color-toolbar {
      position: absolute;
      top: 16px;
      right: 16px;
      display: flex;
      gap: 8px;
      z-index: 25;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    .color-toolbar.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .color-tool-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: none;
      background: rgba(255, 255, 255, 0.9);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: transform 0.2s ease;
    }

    .color-tool-btn:hover {
      transform: scale(1.1);
    }

    .color-tool-btn.active {
      background: #5c4d3d;
    }

    .color-tool-btn.active .color-tool-icon {
      color: #fff;
    }

    .color-tool-icon {
      font-size: 14px;
      color: #5c4d3d;
    }

    .color-tool-icon.bg-icon {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      border: 2px solid #5c4d3d;
      background: linear-gradient(135deg, #faf8f5 50%, #5c4d3d 50%);
    }

    .color-tool-btn.active .bg-icon {
      border-color: #fff;
      background: linear-gradient(135deg, #fff 50%, #5c4d3d 50%);
    }

    .text-icon {
      font-weight: 600;
      font-family: 'Courier Prime', monospace;
    }

    /* Color Picker Dropdown */
    .color-picker {
      position: absolute;
      top: 60px;
      right: 16px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      z-index: 26;
      opacity: 0;
      pointer-events: none;
      transform: translateY(-10px);
      transition: all 0.2s ease;
      min-width: 180px;
    }

    .color-picker.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }

    .color-picker-section {
      margin-bottom: 12px;
    }

    .color-picker-section:last-child {
      margin-bottom: 0;
    }

    .color-picker-label {
      font-size: 9px;
      color: #8b7355;
      letter-spacing: 1px;
      text-transform: lowercase;
      display: block;
      margin-bottom: 8px;
    }

    .color-swatches {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .color-swatch {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
      transition: transform 0.15s ease, border-color 0.15s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }

    .color-swatch:hover {
      transform: scale(1.15);
    }

    .color-swatch.selected {
      border-color: #5c4d3d;
    }

    .color-swatch.light {
      border: 2px solid #e0e0e0;
    }

    .color-swatch.light:hover,
    .color-swatch.light.selected {
      border-color: #5c4d3d;
    }

    /* Eyedropper */
    .eyedropper-icon {
      font-size: 16px;
    }

    .eyedropper-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 30;
      cursor: crosshair;
      display: none;
    }

    .eyedropper-overlay.active {
      display: block;
    }

    .eyedropper-preview {
      position: fixed;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: 3px solid #fff;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      pointer-events: none;
      z-index: 100;
      display: none;
      transform: translate(-50%, -120%);
    }

    .eyedropper-preview.visible {
      display: block;
    }

    .eyedropper-preview::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 8px solid #fff;
    }

    /* Editable Text Box for Edit View */
    .edit-text-box {
      position: absolute;
      padding: 10px 14px;
      min-width: 100px;
      max-width: calc(100% - 20px);
      background: #ffffff;
      color: #1a1a1a;
      z-index: 15;
      touch-action: none;
      user-select: none;
    }

    .edit-text-box.editing {
      cursor: text;
      user-select: text;
    }

    .edit-text-box.draggable {
      cursor: move;
    }

    .edit-text-box-input {
      font-family: 'Courier Prime', 'Courier New', Courier, monospace;
      font-size: 16px;
      line-height: 1.4;
      letter-spacing: 0.5px;
      border: none;
      outline: none;
      background: transparent;
      color: inherit;
      resize: none;
      overflow: hidden;
      display: block;
      caret-color: #5c4d3d;
      padding: 0;
      margin: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
      -webkit-text-size-adjust: 100%;
      -moz-text-size-adjust: 100%;
      text-size-adjust: 100%;
      box-sizing: border-box;
    }

    .edit-text-box-display {
      font-family: 'Courier Prime', 'Courier New', Courier, monospace;
      font-size: 16px;
      line-height: 1.4;
      letter-spacing: 0.5px;
      white-space: pre-wrap;
      word-wrap: break-word;
      min-height: 22px;
      padding: 0;
      margin: 0;
    }


    /* Book View - Clean fullscreen display */
    .book-view-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 60;
      background: #000;
      overflow: hidden;
      animation: bookViewIn 0.35s ease forwards;
    }

    .book-view-container.closing {
      animation: bookViewOut 0.5s ease-out forwards;
    }

    @keyframes bookViewIn {
      from {
        opacity: 0;
        transform: scale(0.98);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes bookViewOut {
      from {
        opacity: 1;
        transform: translateY(0);
      }
      to {
        opacity: 0;
        transform: translateY(100%);
      }
    }

    /* 3D Cube transition */
    #book-view {
      perspective: 4000px;
      perspective-origin: 50% 50%;
      overflow: hidden;
    }

    .cube-wrapper {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      transform-style: preserve-3d;
      z-index: 60;
    }

    .cube-wrapper.cube-animate {
      transition: transform 0.4s cubic-bezier(0.33, 0, 0.2, 1);
    }

    .cube-face {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      background: #000;
      overflow: hidden;
    }

    .cube-face .book-view-bg {
      position: absolute;
      top: -20px;
      left: -20px;
      right: -20px;
      bottom: -20px;
      background-size: cover;
      background-position: center;
      filter: blur(20px) brightness(0.4);
      z-index: 1;
    }

    .cube-face .book-view-cover-wrap {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
    }

    .cube-face .book-view-cover {
      max-width: 70%;
      max-height: 75%;
      object-fit: contain;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }

    .cube-face .book-view-text {
      position: absolute;
      padding: 8px 12px;
      font-size: 14px;
      line-height: 1.4;
      border-radius: 4px;
      max-width: 200px;
      word-wrap: break-word;
    }

    .book-view-bg {
      position: absolute;
      top: -20px;
      left: -20px;
      right: -20px;
      bottom: -20px;
      background-size: cover;
      background-position: center;
      filter: blur(20px) brightness(0.4);
      z-index: 1;
    }

    .book-view-cover-wrap {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 2;
    }

    .book-view-cover {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: 100%;
      object-fit: contain;
    }

    .book-view-text {
      position: absolute;
      padding: 10px 14px;
      background: #ffffff;
      color: #1a1a1a;
      z-index: 3;
      font-family: 'Courier Prime', 'Courier New', Courier, monospace;
      font-size: 16px;
      line-height: 1.4;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-width: calc(100% - 20px);
    }

    /* Book View bottom info overlay */
    .book-view-info {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 24px 20px 32px;
      background: linear-gradient(transparent, rgba(0,0,0,0.8));
      z-index: 4;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .book-view-info.visible {
      opacity: 1;
    }

    .book-view-info-title {
      font-size: 18px;
      color: #fff;
      margin-bottom: 4px;
      letter-spacing: 0.5px;
    }

    .book-view-info-author {
      font-size: 13px;
      color: rgba(255,255,255,0.7);
      margin-bottom: 8px;
    }

    .book-view-info-date {
      font-size: 14px;
      color: #d4c4a8;
      letter-spacing: 1px;
      margin-top: 4px;
    }

    /* More button (shown on second tap) */
    .book-view-more-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: #5c4d3d;
      border: none;
      width: 32px;
      height: 32px;
      cursor: pointer;
      border-radius: 50%;
      z-index: 6;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 3px;
      box-shadow: 0 2px 8px rgba(92, 77, 61, 0.3);
    }

    .book-view-more-btn .dot {
      width: 4px;
      height: 4px;
      background: #faf8f5;
      border-radius: 50%;
    }

    .book-view-more-btn.visible {
      opacity: 1;
      visibility: visible;
    }

    .book-view-more-btn:hover {
      background: #4a3e31;
    }

    /* Action menu */
    .action-menu {
      position: absolute;
      top: 64px;
      right: 20px;
      background: #faf8f5;
      border-radius: 4px;
      padding: 4px 0;
      min-width: 120px;
      z-index: 10;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, visibility 0.2s;
      box-shadow: 0 4px 16px rgba(0,0,0,0.25);
    }

    .action-menu.visible {
      opacity: 1;
      visibility: visible;
    }

    .action-menu-item {
      padding: 12px 20px;
      font-family: 'Courier Prime', 'Courier New', Courier, monospace;
      font-size: 14px;
      color: #5c4d3d;
      cursor: pointer;
      text-align: left;
      letter-spacing: 1px;
      text-transform: lowercase;
    }

    .action-menu-item:hover {
      background: #f0ebe4;
    }

    .action-menu-item.delete {
      color: #c9a088;
    }

    .action-menu-item + .action-menu-item {
      border-top: 1px solid #e8e4df;
    }


    /* Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(61, 52, 40, 0.6);
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: #faf8f5;
      padding: 28px;
      max-width: 320px;
      width: 90%;
      text-align: center;
      border-radius: 4px;
    }

    .modal h3 {
      font-size: 16px;
      font-weight: 400;
      letter-spacing: 2px;
      margin-bottom: 12px;
      text-transform: lowercase;
      color: #5c4d3d;
    }

    .modal p {
      color: #8b7355;
      margin-bottom: 24px;
      font-size: 14px;
      line-height: 1.5;
    }

    .modal-buttons {
      display: flex;
      gap: 12px;
    }

    .modal-btn {
      flex: 1;
      padding: 12px;
      font-family: inherit;
      font-size: 13px;
      cursor: pointer;
      letter-spacing: 1px;
      text-transform: lowercase;
    }

    .modal-btn.cancel {
      background: #fff;
      border: 1px solid #e8e4df;
      color: #5c4d3d;
    }

    .modal-btn.confirm {
      background: #c9a088;
      border: none;
      color: #fff;
    }

    .modal-btn.cancel:hover {
      background: #f5f0ea;
    }

    .modal-btn.confirm:hover {
      background: #b8847a;
    }

  </style>
</head>
<body>
  <div class="container">
    <!-- Home View -->
    <div id="home-view" class="view active">
      <div class="sticky-header">
        <div class="logo-container">
          <div class="logo-icon"></div>
          <h1><span>between</span><span>pages</span></h1>
        </div>
        <div class="header-divider"></div>
        <p class="tagline">thoughts left between the pages</p>
      </div>
      <div id="timeline" class="timeline">
        <!-- Timeline content will be rendered here -->
      </div>
      <div id="year-indicator" class="year-indicator"></div>
      <button class="fab" onclick="showAddView()">+</button>
    </div>

    <!-- Add Book View -->
    <div id="add-view" class="view">
      <div class="header">
        <button class="back-btn" onclick="showHomeView()">&larr;</button>
        <span class="header-title">add book</span>
      </div>

      <div class="tabs">
        <button class="tab active" onclick="switchTab('search')">search</button>
        <button class="tab" onclick="switchTab('manual')">add by yourself</button>
      </div>

      <!-- Search Tab -->
      <div id="search-tab" class="tab-content active">
        <div class="search-row">
          <input type="text" id="search-input" class="search-input" placeholder="search by title or author..." onkeypress="handleSearchKeypress(event)">
          <button class="search-btn" onclick="searchBooks()">go</button>
        </div>
        <div id="search-results" class="search-results">
          <div class="search-message">search for a book above</div>
        </div>
      </div>

      <!-- Manual Tab -->
      <div id="manual-tab" class="tab-content">
        <div class="form">
          <input type="text" id="manual-title" class="form-input" placeholder="book title *">
          <input type="text" id="manual-author" class="form-input" placeholder="author">
          <input type="text" id="manual-year" class="form-input" placeholder="year read (e.g. 2024)">

          <div class="cover-section">
            <label class="cover-label">cover image</label>
            <div class="cover-options">
              <div class="cover-picker">
                <div id="cover-preview-container" class="cover-placeholder" onclick="document.getElementById('cover-input').click()">
                  <span class="cover-placeholder-icon">+</span>
                  <span class="cover-placeholder-text">upload</span>
                </div>
                <input type="file" id="cover-input" accept="image/*" onchange="handleImageUpload(event)">
              </div>
              <div class="cover-url-section">
                <span class="cover-or">or</span>
                <input type="text" id="cover-url-input" class="form-input cover-url-input" placeholder="paste image URL..." onchange="handleCoverUrlInput(event)">
              </div>
            </div>
          </div>

          <button class="save-btn" onclick="handleManualSubmit()">add book</button>
        </div>
      </div>
    </div>

    <!-- Book View (clean fullscreen display) -->
    <div id="book-view" class="view">
      <div class="book-view-container" id="book-view-container">
        <div class="book-view-bg" id="book-view-bg"></div>
        <div class="book-view-cover-wrap" id="book-view-cover-wrap">
          <img id="book-view-cover" class="book-view-cover" src="" alt="">
        </div>

        <!-- More button (shown on second tap) -->
        <button id="book-view-more-btn" class="book-view-more-btn" onclick="toggleActionMenu(event)"><span class="dot"></span><span class="dot"></span><span class="dot"></span></button>

        <!-- Bottom info overlay (shown on second tap) -->
        <div id="book-view-info" class="book-view-info">
          <div id="book-view-info-title" class="book-view-info-title"></div>
          <div id="book-view-info-author" class="book-view-info-author"></div>
          <div id="book-view-info-date" class="book-view-info-date"></div>
        </div>

        <!-- Action menu (shown when ... is tapped) -->
        <div id="action-menu" class="action-menu">
          <div class="action-menu-item" onclick="openEditView()">edit</div>
          <div class="action-menu-item delete" onclick="showDeleteModal()">delete</div>
        </div>
      </div>
    </div>

    <!-- Edit View -->
    <div id="edit-view" class="view">
      <div class="edit-view-container" id="edit-view-container">
        <div class="edit-cover-bg" id="edit-cover-bg"></div>

        <!-- Color picker toolbar (top right) -->
        <div id="color-toolbar" class="color-toolbar">
          <button class="color-tool-btn" id="bg-color-btn" onclick="toggleColorPicker('bg')" title="Background color">
            <span class="color-tool-icon bg-icon"></span>
          </button>
          <button class="color-tool-btn" id="text-color-btn" onclick="toggleColorPicker('text')" title="Text color">
            <span class="color-tool-icon text-icon">A</span>
          </button>
          <button class="color-tool-btn" id="eyedropper-btn" onclick="toggleEyedropper()" title="Pick color from cover">
            <span class="color-tool-icon eyedropper-icon">◉</span>
          </button>
        </div>

        <!-- Color palette dropdown -->
        <div id="color-picker" class="color-picker">
          <div class="color-picker-section">
            <div id="palette-colors" class="color-swatches"></div>
          </div>
        </div>

        <!-- Eyedropper overlay -->
        <div id="eyedropper-overlay" class="eyedropper-overlay"></div>

        <div class="edit-cover-wrap" id="edit-cover-wrap">
          <img id="edit-cover" class="edit-cover" src="" alt="" crossorigin="anonymous">

          <!-- Editable text box -->
          <div id="edit-text-box" class="edit-text-box" style="display: none;">
            <textarea id="edit-text-box-input" class="edit-text-box-input" rows="1" placeholder="" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"></textarea>
            <div id="edit-text-box-display" class="edit-text-box-display" style="display: none;"></div>
          </div>

        </div>

        <!-- Trash icon for deleting text box -->
        <div id="edit-trash" class="edit-trash"></div>

        <!-- Save button -->
        <button class="edit-save-btn" onclick="handleSave()">save</button>
      </div>
    </div>
  </div>

  <!-- Delete Confirmation Modal -->
  <div id="delete-modal" class="modal-overlay">
    <div class="modal">
      <h3>delete book</h3>
      <p>remove this book from your journal?</p>
      <div class="modal-buttons">
        <button class="modal-btn cancel" onclick="hideDeleteModal()">cancel</button>
        <button class="modal-btn confirm" onclick="confirmDelete()">delete</button>
      </div>
    </div>
  </div>

  <script>
    // Storage key
    const BOOKS_KEY = 'between_pages_books_v5';

    // Sample books for demo
    const SAMPLE_BOOKS = [
      {
        id: 'sample_1',
        title: 'The Great Gatsby',
        author: 'F. Scott Fitzgerald',
        coverUrl: 'https://covers.openlibrary.org/b/isbn/9780743273565-L.jpg',
        reflection: 'A haunting portrayal of the American Dream',
        textBoxColor: '#ffffff',
        textBoxX: 20,
        textBoxY: 350,
        dateAdded: '2024-03-15',
        yearRead: '2024',
        summary: 'A story of the mysteriously wealthy Jay Gatsby and his love for Daisy Buchanan, set against the backdrop of 1920s Long Island.',
      },
      {
        id: 'sample_2',
        title: 'The Little Prince',
        author: 'Antoine de Saint-Exupéry',
        coverUrl: 'https://covers.openlibrary.org/b/isbn/9780156012195-L.jpg',
        reflection: 'All grown-ups were once children... but only few remember it.',
        textBoxColor: '#1a1a1a',
        textBoxX: 20,
        textBoxY: 280,
        dateAdded: '2024-06-20',
        yearRead: '2024',
        summary: 'A poetic tale of a young prince who travels from planet to planet.',
      },
      {
        id: 'sample_3',
        title: 'Norwegian Wood',
        author: 'Haruki Murakami',
        coverUrl: 'https://covers.openlibrary.org/b/isbn/9780375704024-L.jpg',
        reflection: 'Deep thoughts on youth, love and loss',
        textBoxColor: '#3c3c3c',
        textBoxX: 20,
        textBoxY: 320,
        dateAdded: '2023-05-22',
        yearRead: '2023',
        summary: 'Set in Tokyo during the late 1960s, this nostalgic story follows Toru Watanabe.',
      },
    ];

    // App state
    let currentView = 'home';
    let selectedBook = null;
    let uploadedCoverBase64 = null;

    // Book View state
    let bookViewTapCount = 0;
    let bookViewTapTimer = null;
    let bookViewSwipeStartY = 0;
    let bookViewSwipeStartX = 0;
    let actionMenuVisible = false;
    let overlayVisible = false;

    // Edit View state
    let editTextBoxes = []; // Array of {id, text, x, y, color, textColor}
    let currentTextBoxId = null;
    let textBoxX = 0;
    let textBoxY = 0;
    let isEditing = false;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let textBoxStartX = 0;
    let textBoxStartY = 0;
    let longPressTimer = null;
    let coverWrapRect = null;

    // Color picker state
    let colorPickerMode = null; // 'bg' or 'text'
    let extractedColors = [];
    let eyedropperActive = false;
    let eyedropperMode = 'bg'; // 'bg' or 'text'
    let eyedropperCanvas = null;
    let eyedropperCtx = null;
    const appPalette = [
      '#ffffff', '#f5f5f5', '#faf8f5', '#f5ebe0',
      '#d4cec4', '#b8a99a', '#8b7355', '#5c4d3d',
      '#1a1a1a', '#2d2d2d', '#4a4a4a', '#6b6b6b'
    ];

    // Initialize app
    document.addEventListener('DOMContentLoaded', () => {
      initializeBooks();
      renderTimeline();
      setupHistoryNavigation();
      setupBookView();
      setupEditView();
      setupYearIndicator();
    });

    // Initialize books with samples if empty
    async function initializeBooks() {
      const data = localStorage.getItem(BOOKS_KEY);
      if (!data) {
        localStorage.setItem(BOOKS_KEY, JSON.stringify(SAMPLE_BOOKS));
      }
      renderTimeline();
    }

    // History navigation
    function setupHistoryNavigation() {
      window.addEventListener('popstate', (event) => {
        if (event.state && event.state.view) {
          if (event.state.view === 'home') {
            showHomeView(false);
          } else if (event.state.view === 'add') {
            showAddView(false);
          } else if (event.state.view === 'book' && event.state.bookId) {
            const book = getBooks().find(b => b.id === event.state.bookId);
            if (book) showBookView(book, false);
            else showHomeView(false);
          } else if (event.state.view === 'edit' && event.state.bookId) {
            const book = getBooks().find(b => b.id === event.state.bookId);
            if (book) showEditView(book, false);
            else showHomeView(false);
          }
        } else {
          showHomeView(false);
        }
      });
      history.replaceState({ view: 'home' }, '', '');
    }

    // Storage functions
    function getBooks() {
      const data = localStorage.getItem(BOOKS_KEY);
      return data ? JSON.parse(data) : SAMPLE_BOOKS;
    }

    function saveBooks(books) {
      localStorage.setItem(BOOKS_KEY, JSON.stringify(books));
    }

    function addBook(book) {
      const books = getBooks();
      book.id = `book_${Date.now()}`;
      book.dateAdded = new Date().toISOString();
      book.textBoxes = []; // Array of {text, x, y, color}
      book.yearRead = new Date().getFullYear().toString();
      book.summary = book.summary || '';
      books.unshift(book);
      saveBooks(books);
      return book;
    }

    function updateBook(bookId, updates) {
      const books = getBooks();
      const index = books.findIndex(b => b.id === bookId);
      if (index !== -1) {
        books[index] = { ...books[index], ...updates };
        saveBooks(books);
        return books[index];
      }
      return null;
    }

    function deleteBook(bookId) {
      const books = getBooks();
      saveBooks(books.filter(b => b.id !== bookId));
    }

    // View navigation
    function showHomeView(pushState = true, animate = true) {
      const bookViewContainer = document.getElementById('book-view-container');

      // If coming from Book View, animate out
      if (animate && currentView === 'book') {
        bookViewContainer.classList.add('closing');
        setTimeout(() => {
          bookViewContainer.classList.remove('closing');
          completeShowHomeView(pushState);
        }, 480);
      } else {
        completeShowHomeView(pushState);
      }
    }

    function completeShowHomeView(pushState) {
      document.getElementById('home-view').classList.add('active');
      document.getElementById('add-view').classList.remove('active');
      document.getElementById('book-view').classList.remove('active');
      document.getElementById('edit-view').classList.remove('active');
      currentView = 'home';
      selectedBook = null;
      renderTimeline();
      if (pushState) history.pushState({ view: 'home' }, '', '');
    }

    function showAddView(pushState = true) {
      document.getElementById('home-view').classList.remove('active');
      document.getElementById('add-view').classList.add('active');
      document.getElementById('book-view').classList.remove('active');
      document.getElementById('edit-view').classList.remove('active');
      currentView = 'add';
      resetAddForm();
      if (pushState) history.pushState({ view: 'add' }, '', '');
    }

    function showBookView(book, pushState = true, animate = true) {
      document.getElementById('home-view').classList.remove('active');
      document.getElementById('add-view').classList.remove('active');
      document.getElementById('book-view').classList.add('active');
      document.getElementById('edit-view').classList.remove('active');
      currentView = 'book';
      selectedBook = book;
      renderBookView(animate);
      if (pushState) history.pushState({ view: 'book', bookId: book.id }, '', '');
    }

    function showEditView(book, pushState = true) {
      document.getElementById('home-view').classList.remove('active');
      document.getElementById('add-view').classList.remove('active');
      document.getElementById('book-view').classList.remove('active');
      document.getElementById('edit-view').classList.add('active');
      currentView = 'edit';
      selectedBook = book;
      renderEditView();
      if (pushState) history.pushState({ view: 'edit', bookId: book.id }, '', '');
    }

    function openEditView() {
      hideActionMenu();
      if (selectedBook) {
        showEditView(selectedBook);
      }
    }

    // Book View setup and rendering
    function setupBookView() {
      const container = document.getElementById('book-view-container');

      // Touch events for tap and swipe
      container.addEventListener('touchstart', handleBookViewTouchStart, { passive: false });
      container.addEventListener('touchmove', handleBookViewTouchMove, { passive: false });
      container.addEventListener('touchend', handleBookViewTouchEnd);

      // Mouse click for desktop
      container.addEventListener('click', handleBookViewClick);
    }

    function renderBookView(animate = true) {
      const book = selectedBook;
      const container = document.getElementById('book-view-container');

      // Reset state
      bookViewTapCount = 0;
      overlayVisible = false;
      actionMenuVisible = false;
      container.classList.remove('closing');

      // Control animation
      if (animate) {
        container.style.animation = 'bookViewIn 0.35s ease forwards';
      } else {
        container.style.animation = 'none';
      }

      document.getElementById('book-view-info').classList.remove('visible');
      document.getElementById('book-view-more-btn').classList.remove('visible');
      document.getElementById('action-menu').classList.remove('visible');

      // Set cover image
      const coverUrl = book.coverUrl || 'https://via.placeholder.com/300x450/f0f0f0/999?text=No+Cover';
      document.getElementById('book-view-cover').src = coverUrl;
      document.getElementById('book-view-bg').style.backgroundImage = `url(${coverUrl})`;

      // Pre-load edit view cover to avoid delay when switching
      document.getElementById('edit-cover').src = coverUrl;
      document.getElementById('edit-cover-bg').style.backgroundImage = `url(${coverUrl})`;

      // Clear existing text boxes
      const textContainer = document.getElementById('book-view-cover-wrap');
      textContainer.querySelectorAll('.book-view-text').forEach(el => el.remove());

      // Get text boxes (support both old and new format)
      const textBoxes = book.textBoxes || (book.reflection ? [{
        text: book.reflection,
        x: book.textBoxX || 20,
        y: book.textBoxY || 300,
        color: book.textBoxColor || '#ffffff'
      }] : []);

      // Render all text boxes
      textBoxes.forEach(tb => {
        if (!tb.text) return;
        const textEl = document.createElement('div');
        textEl.className = 'book-view-text';
        const bgColor = tb.color || '#ffffff';
        const textColor = tb.textColor || (isLightColorSimple(bgColor) ? '#1a1a1a' : '#ffffff');
        textEl.style.display = 'block';
        textEl.textContent = tb.text;
        textEl.style.left = tb.x + 'px';
        textEl.style.top = tb.y + 'px';
        textEl.style.backgroundColor = bgColor;
        textEl.style.color = textColor;
        textContainer.appendChild(textEl);
      });

      function isLightColorSimple(hex) {
        if (!hex || hex.length < 7) return true;
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return (r * 299 + g * 587 + b * 114) / 1000 > 180;
      }

      // Set info overlay
      const yearRead = book.yearRead || new Date(book.dateAdded).getFullYear().toString();
      document.getElementById('book-view-info-title').textContent = book.title;
      document.getElementById('book-view-info-author').textContent = book.author || 'Unknown Author';
      document.getElementById('book-view-info-date').textContent = `read in ${yearRead}`;

      // Preload adjacent book covers
      preloadAdjacentBooks();
    }

    function preloadAdjacentBooks() {
      const books = getBooks();
      const currentIndex = books.findIndex(b => b.id === selectedBook.id);

      // Preload previous book cover
      if (currentIndex > 0) {
        const prevBook = books[currentIndex - 1];
        if (prevBook.coverUrl) {
          const img = new Image();
          img.src = prevBook.coverUrl;
        }
      }

      // Preload next book cover
      if (currentIndex < books.length - 1) {
        const nextBook = books[currentIndex + 1];
        if (nextBook.coverUrl) {
          const img = new Image();
          img.src = nextBook.coverUrl;
        }
      }
    }

    // Cube gesture state
    let cubeGestureActive = false;
    let cubeDirection = null; // 'left' or 'right'
    let cubeDragStartX = 0;
    let cubeDragStartY = 0;
    let cubeCurrentX = 0;
    let cubeWrapper = null;
    let cubeThreshold = 0;
    let cubeIsAnimating = false;
    let cubePrevBook = null;
    let cubeNextBook = null;
    let cubeHalfWidth = 0;

    function handleBookViewTouchStart(e) {
      if (currentView !== 'book') return;
      if (e.target.closest('.action-menu') || e.target.closest('.book-view-more-btn')) return;
      if (cubeIsAnimating) return;

      cubeDragStartX = e.touches[0].clientX;
      cubeDragStartY = e.touches[0].clientY;
      cubeCurrentX = 0;
      cubeGestureActive = false;
      cubeDirection = null;
      cubeThreshold = window.innerWidth * 0.28;
      cubeHalfWidth = window.innerWidth / 2;

      // Get adjacent books
      const books = getBooks();
      const currentIndex = books.findIndex(b => b.id === selectedBook.id);
      cubePrevBook = currentIndex > 0 ? books[currentIndex - 1] : null;
      cubeNextBook = currentIndex < books.length - 1 ? books[currentIndex + 1] : null;
    }

    function handleBookViewTouchMove(e) {
      if (currentView !== 'book') return;
      if (cubeIsAnimating) return;

      const touchX = e.touches[0].clientX;
      const touchY = e.touches[0].clientY;
      const deltaX = touchX - cubeDragStartX;
      const deltaY = touchY - cubeDragStartY;

      // Check for vertical swipe (swipe down to exit)
      if (!cubeGestureActive && deltaY > 60 && Math.abs(deltaX) < 40) {
        showHomeView();
        return;
      }

      // Determine if this is a horizontal gesture
      if (!cubeGestureActive && Math.abs(deltaX) > 15 && Math.abs(deltaX) > Math.abs(deltaY) * 1.5) {
        // Check if we can go in this direction
        if (deltaX < 0 && !cubeNextBook) return;
        if (deltaX > 0 && !cubePrevBook) return;

        cubeGestureActive = true;
        cubeDirection = deltaX < 0 ? 'left' : 'right';

        // Create the cube
        createCube(cubeDirection);

        e.preventDefault();
      }

      if (cubeGestureActive) {
        e.preventDefault();
        cubeCurrentX = deltaX;

        // Limit drag range
        const maxDrag = window.innerWidth;
        if (cubeDirection === 'left') {
          cubeCurrentX = Math.max(Math.min(cubeCurrentX, 0), -maxDrag);
        } else {
          cubeCurrentX = Math.min(Math.max(cubeCurrentX, 0), maxDrag);
        }

        updateCubeRotation();
      }
    }

    function handleBookViewTouchEnd(e) {
      if (currentView !== 'book') return;
      if (e.target.closest('.action-menu') || e.target.closest('.book-view-more-btn')) return;

      if (cubeGestureActive) {
        cubeGestureActive = false;
        const passedThreshold = Math.abs(cubeCurrentX) > cubeThreshold;

        if (passedThreshold) {
          completeCubeTransition();
        } else {
          snapBackCube();
        }
      } else if (!cubeIsAnimating) {
        handleBookViewTap();
      }
    }

    function handleBookViewClick(e) {
      if (currentView !== 'book') return;
      if (e.target.closest('.action-menu') || e.target.closest('.book-view-more-btn')) return;
      if (cubeIsAnimating) return;

      if (actionMenuVisible) {
        hideActionMenu();
        return;
      }

      handleBookViewTap();
    }

    function handleBookViewTap() {
      toggleOverlay();
    }

    function createCube(direction) {
      const container = document.getElementById('book-view-container');
      const bookView = document.getElementById('book-view');
      const adjacentBook = direction === 'left' ? cubeNextBook : cubePrevBook;

      if (!adjacentBook) return;

      // Hide original container
      container.style.visibility = 'hidden';

      // Create cube wrapper - this is what rotates as one unit
      cubeWrapper = document.createElement('div');
      cubeWrapper.className = 'cube-wrapper';
      cubeWrapper.id = 'cube-wrapper';

      // Create front face (current book)
      const frontFace = createCubeFace(selectedBook);
      frontFace.classList.add('cube-face-front');
      frontFace.style.transform = `translateZ(${cubeHalfWidth}px)`;

      // Create adjacent face - rotated 90deg and pushed forward (places it on the side)
      const adjacentFace = createCubeFace(adjacentBook);
      adjacentFace.classList.add('cube-face-adjacent');

      if (direction === 'left') {
        adjacentFace.style.transform = `rotateY(90deg) translateZ(${cubeHalfWidth}px)`;
      } else {
        adjacentFace.style.transform = `rotateY(-90deg) translateZ(${cubeHalfWidth}px)`;
      }

      cubeWrapper.appendChild(frontFace);
      cubeWrapper.appendChild(adjacentFace);
      bookView.appendChild(cubeWrapper);
    }

    function createCubeFace(book) {
      const face = document.createElement('div');
      face.className = 'cube-face';

      const coverUrl = book.coverUrl || 'https://via.placeholder.com/300x450/f0f0f0/999?text=No+Cover';

      // Background
      const bg = document.createElement('div');
      bg.className = 'book-view-bg';
      bg.style.backgroundImage = `url(${coverUrl})`;
      face.appendChild(bg);

      // Cover wrap
      const coverWrap = document.createElement('div');
      coverWrap.className = 'book-view-cover-wrap';

      const cover = document.createElement('img');
      cover.className = 'book-view-cover';
      cover.src = coverUrl;
      coverWrap.appendChild(cover);

      // Text boxes
      const textBoxes = book.textBoxes || (book.reflection ? [{
        text: book.reflection,
        x: book.textBoxX || 20,
        y: book.textBoxY || 300,
        color: book.textBoxColor || '#ffffff'
      }] : []);

      textBoxes.forEach(tb => {
        if (!tb.text) return;
        const textEl = document.createElement('div');
        textEl.className = 'book-view-text';
        const bgColor = tb.color || '#ffffff';
        const textColor = tb.textColor || (isLightColorForCube(bgColor) ? '#1a1a1a' : '#ffffff');
        textEl.style.cssText = `
          display: block;
          left: ${tb.x}px;
          top: ${tb.y}px;
          background-color: ${bgColor};
          color: ${textColor};
        `;
        textEl.textContent = tb.text;
        coverWrap.appendChild(textEl);
      });

      face.appendChild(coverWrap);

      return face;
    }

    function updateCubeRotation() {
      if (!cubeWrapper) return;

      const screenWidth = window.innerWidth;
      const progress = cubeCurrentX / screenWidth;

      // Add slight deceleration near 90deg
      const absProgress = Math.abs(progress);
      const easedProgress = 1 - Math.pow(1 - absProgress, 2);
      const rotation = Math.sign(progress) * easedProgress * 90;

      // Scale compensation to keep faces fullscreen
      const perspective = 4000;
      const baseScale = (perspective + cubeHalfWidth) / perspective;
      // Extra boost during rotation
      const rotationRad = Math.abs(rotation) * Math.PI / 180;
      const rotationBoost = 1 + Math.sin(rotationRad) * (cubeHalfWidth / perspective) * 2;
      const scale = baseScale * rotationBoost;

      // Rotate the entire cube as one unit
      cubeWrapper.style.transform = `translateZ(-${cubeHalfWidth}px) scale(${scale}) rotateY(${rotation}deg)`;
    }

    function completeCubeTransition() {
      cubeIsAnimating = true;
      const newBook = cubeDirection === 'left' ? cubeNextBook : cubePrevBook;

      // Add transition
      cubeWrapper.classList.add('cube-animate');

      // Complete rotation to 90 degrees
      const finalRotation = cubeDirection === 'left' ? -90 : 90;
      const perspective = 4000;
      const baseScale = (perspective + cubeHalfWidth) / perspective;
      cubeWrapper.style.transform = `translateZ(-${cubeHalfWidth}px) scale(${baseScale}) rotateY(${finalRotation}deg)`;

      setTimeout(() => {
        // Update state
        selectedBook = newBook;
        overlayVisible = false;

        // Show and update original container
        const container = document.getElementById('book-view-container');
        container.style.visibility = 'visible';
        renderBookView(false);

        // Clean up cube
        if (cubeWrapper) {
          cubeWrapper.remove();
          cubeWrapper = null;
        }

        cubeIsAnimating = false;
      }, 400);
    }

    function snapBackCube() {
      cubeIsAnimating = true;

      // Add transition
      cubeWrapper.classList.add('cube-animate');

      // Return to 0 degrees
      const perspective = 4000;
      const baseScale = (perspective + cubeHalfWidth) / perspective;
      cubeWrapper.style.transform = `translateZ(-${cubeHalfWidth}px) scale(${baseScale}) rotateY(0deg)`;

      setTimeout(() => {
        // Show original container
        const container = document.getElementById('book-view-container');
        container.style.visibility = 'visible';

        // Clean up cube
        if (cubeWrapper) {
          cubeWrapper.remove();
          cubeWrapper = null;
        }

        cubeIsAnimating = false;
      }, 400);
    }

    function isLightColorForCube(hex) {
      if (!hex || hex.length < 7) return true;
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return (r * 299 + g * 587 + b * 114) / 1000 > 180;
    }

    function toggleOverlay() {
      overlayVisible = !overlayVisible;
      const infoEl = document.getElementById('book-view-info');
      const moreBtn = document.getElementById('book-view-more-btn');

      if (overlayVisible) {
        infoEl.classList.add('visible');
        moreBtn.classList.add('visible');
      } else {
        infoEl.classList.remove('visible');
        moreBtn.classList.remove('visible');
        hideActionMenu();
      }
    }

    function toggleActionMenu(e) {
      e.stopPropagation();
      if (actionMenuVisible) {
        hideActionMenu();
      } else {
        showActionMenu();
      }
    }

    function showActionMenu() {
      actionMenuVisible = true;
      document.getElementById('action-menu').classList.add('visible');
    }

    function hideActionMenu() {
      actionMenuVisible = false;
      document.getElementById('action-menu').classList.remove('visible');
    }

    // Tab switching
    function switchTab(tab) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

      if (tab === 'search') {
        document.querySelector('.tab:first-child').classList.add('active');
        document.getElementById('search-tab').classList.add('active');
      } else {
        document.querySelector('.tab:last-child').classList.add('active');
        document.getElementById('manual-tab').classList.add('active');
      }
    }

    // Render timeline (grouped by year)
    function renderTimeline() {
      const container = document.getElementById('timeline');
      const books = getBooks();

      if (books.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <h2>no books yet</h2>
            <p>tap + to begin your journal</p>
          </div>
        `;
        return;
      }

      // Group by year
      const grouped = {};
      books.forEach(book => {
        const year = book.yearRead || new Date(book.dateAdded).getFullYear().toString();
        if (!grouped[year]) grouped[year] = [];
        grouped[year].push(book);
      });

      // Sort years descending
      const sortedYears = Object.keys(grouped).sort((a, b) => b - a);

      let html = '';
      sortedYears.forEach(year => {
        html += `
          <div class="year-section" data-year="${year}">
            <div class="year-header">
              <div class="year-line"></div>
              <span class="year-text">${year}</span>
              <div class="year-line"></div>
            </div>
            <div class="year-grid">
              ${grouped[year].map(book => renderBookCard(book)).join('')}
            </div>
          </div>
        `;
      });

      container.innerHTML = html;
    }

    function renderBookCard(book) {
      const coverUrl = book.coverUrl || 'https://via.placeholder.com/128x192/f0f0f0/999?text=No+Cover';

      return `
        <div class="book-card" onclick='showBookView(${JSON.stringify(book).replace(/'/g, "&#39;")})'>
          <div class="card-inner">
            <img src="${coverUrl}" alt="${book.title}" class="card-cover" onerror="this.src='https://via.placeholder.com/128x192/f0f0f0/999?text=No+Cover'">
          </div>
          <div class="card-title">${book.title}</div>
          <div class="card-author">${book.author || 'Unknown Author'}</div>
        </div>
      `;
    }

    // Year indicator on scroll
    function setupYearIndicator() {
      const timeline = document.getElementById('timeline');
      const indicator = document.getElementById('year-indicator');
      let hideTimeout = null;

      window.addEventListener('scroll', () => {
        if (currentView !== 'home') return;

        const sections = timeline.querySelectorAll('.year-section');
        const scrollTop = window.scrollY;

        // Don't show if at the very top
        if (scrollTop < 100) {
          indicator.classList.remove('visible');
          return;
        }

        // Find current year section
        let currentYear = null;
        sections.forEach(section => {
          const rect = section.getBoundingClientRect();
          if (rect.top <= 120) {
            currentYear = section.dataset.year;
          }
        });

        if (currentYear) {
          indicator.textContent = currentYear;
          indicator.classList.add('visible');

          // Hide after a delay
          if (hideTimeout) clearTimeout(hideTimeout);
          hideTimeout = setTimeout(() => {
            indicator.classList.remove('visible');
          }, 1500);
        }
      });
    }

    // Setup Edit View
    function setupEditView() {
      const coverWrap = document.getElementById('edit-cover-wrap');
      const textBox = document.getElementById('edit-text-box');
      const textInput = document.getElementById('edit-text-box-input');

      // Tap on cover to create/show text box
      coverWrap.addEventListener('click', handleEditCoverTap);

      // Text input handling
      textInput.addEventListener('input', autoGrowTextarea);
      textInput.addEventListener('blur', handleEditTextBlur);
      textInput.addEventListener('focus', handleEditTextFocus);

      // Text box touch/mouse events for dragging
      textBox.addEventListener('touchstart', handleEditTextBoxTouchStart, { passive: false });
      textBox.addEventListener('touchmove', handleEditTextBoxTouchMove, { passive: false });
      textBox.addEventListener('touchend', handleEditTextBoxTouchEnd);
      textBox.addEventListener('mousedown', handleEditTextBoxMouseDown);
      document.addEventListener('mousemove', handleEditTextBoxMouseMove);
      document.addEventListener('mouseup', handleEditTextBoxMouseUp);

      // Click on text box display to enter edit mode
      textBox.addEventListener('click', handleEditTextBoxClick);
    }

    // Render Edit View
    function renderEditView() {
      const book = selectedBook;
      const editCover = document.getElementById('edit-cover');
      const editCoverBg = document.getElementById('edit-cover-bg');
      const editCoverWrap = document.getElementById('edit-cover-wrap');
      const textBox = document.getElementById('edit-text-box');
      const textInput = document.getElementById('edit-text-box-input');
      const textDisplay = document.getElementById('edit-text-box-display');

      // Set cover image
      const coverUrl = book.coverUrl || 'https://via.placeholder.com/300x450/f0f0f0/999?text=No+Cover';
      editCover.src = coverUrl;
      editCoverBg.style.backgroundImage = `url(${coverUrl})`;

      // Extract colors from cover when loaded
      editCover.onload = () => extractColorsFromCover(editCover);

      // Load existing text boxes (support both old and new format)
      if (book.textBoxes && book.textBoxes.length > 0) {
        editTextBoxes = book.textBoxes.map((tb, i) => ({
          id: i,
          text: tb.text,
          x: tb.x,
          y: tb.y,
          color: tb.color || '#ffffff',
          textColor: tb.textColor || null
        }));
      } else if (book.reflection) {
        editTextBoxes = [{
          id: 0,
          text: book.reflection,
          x: book.textBoxX || 20,
          y: book.textBoxY || 300,
          color: book.textBoxColor || '#ffffff',
          textColor: null
        }];
      } else {
        editTextBoxes = [];
      }

      // Hide color picker
      hideColorPicker();

      // Render all text boxes as static elements
      renderEditTextBoxes();

      // Hide the active text box editor initially
      textBox.style.display = 'none';
      textInput.value = '';
      textDisplay.textContent = '';
      currentTextBoxId = null;

      isEditing = false;
      isDragging = false;
    }

    function renderEditTextBoxes() {
      const editCoverWrap = document.getElementById('edit-cover-wrap');

      // Remove existing static text boxes
      editCoverWrap.querySelectorAll('.edit-text-static').forEach(el => el.remove());

      // Render each text box
      editTextBoxes.forEach(tb => {
        if (!tb.text) return;
        const el = document.createElement('div');
        el.className = 'edit-text-static edit-text-box draggable';
        el.dataset.id = tb.id;
        el.style.left = tb.x + 'px';
        el.style.top = tb.y + 'px';
        el.style.backgroundColor = tb.color || '#ffffff';
        const textColor = tb.textColor || (isLightColor(tb.color || '#ffffff') ? '#1a1a1a' : '#ffffff');
        el.style.color = textColor;
        el.innerHTML = `<div class="edit-text-box-display" style="display:block;">${tb.text}</div>`;
        el.addEventListener('click', (e) => handleStaticTextBoxClick(e, tb.id));
        el.addEventListener('touchstart', (e) => handleStaticTextBoxTouchStart(e, tb.id), { passive: false });
        el.addEventListener('touchmove', handleStaticTextBoxTouchMove, { passive: false });
        el.addEventListener('touchend', handleStaticTextBoxTouchEnd);
        el.addEventListener('mousedown', (e) => handleStaticTextBoxMouseDown(e, tb.id));
        editCoverWrap.appendChild(el);
      });
    }

    function handleStaticTextBoxClick(e, id) {
      e.stopPropagation();
      if (!isDragging) {
        activateTextBox(id);
      }
    }

    function handleStaticTextBoxTouchStart(e, id) {
      if (currentView !== 'edit') return;
      const touch = e.touches[0];
      const tb = editTextBoxes.find(t => t.id === id);
      if (!tb) return;

      currentTextBoxId = id;
      textBoxX = tb.x;
      textBoxY = tb.y;
      textBoxStartX = tb.x;
      textBoxStartY = tb.y;
      dragStartX = touch.clientX;
      dragStartY = touch.clientY;
      coverWrapRect = document.getElementById('edit-cover-wrap').getBoundingClientRect();

      longPressTimer = setTimeout(() => {
        isDragging = true;
        e.target.closest('.edit-text-static').style.opacity = '0.8';
        document.getElementById('edit-trash').classList.add('visible');
      }, 150);
    }

    function handleStaticTextBoxTouchMove(e) {
      if (currentView !== 'edit') return;

      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
        isDragging = true;
        e.target.closest('.edit-text-static').style.opacity = '0.8';
        document.getElementById('edit-trash').classList.add('visible');
      }

      if (!isDragging) return;
      e.preventDefault();

      const touch = e.touches[0];
      const deltaX = touch.clientX - dragStartX;
      const deltaY = touch.clientY - dragStartY;

      let newX = textBoxStartX + deltaX;
      let newY = textBoxStartY + deltaY;

      const el = e.target.closest('.edit-text-static');
      const maxX = coverWrapRect.width - el.offsetWidth - 10;
      const maxY = coverWrapRect.height - el.offsetHeight - 80;
      newX = Math.max(10, Math.min(newX, maxX));
      newY = Math.max(10, Math.min(newY, maxY));

      textBoxX = newX;
      textBoxY = newY;
      el.style.left = newX + 'px';
      el.style.top = newY + 'px';

      // Update in array
      const tb = editTextBoxes.find(t => t.id === currentTextBoxId);
      if (tb) {
        tb.x = newX;
        tb.y = newY;
      }

      checkTrashHover(touch.clientX, touch.clientY);
    }

    function handleStaticTextBoxTouchEnd(e) {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }

      const trash = document.getElementById('edit-trash');
      const el = e.target.closest('.edit-text-static');

      if (isDragging && trash.classList.contains('active')) {
        // Delete this text box
        editTextBoxes = editTextBoxes.filter(tb => tb.id !== currentTextBoxId);
        el.remove();
      } else if (el) {
        el.style.opacity = '1';
      }

      trash.classList.remove('visible', 'active');
      isDragging = false;
      coverWrapRect = null;
    }

    function handleStaticTextBoxMouseDown(e, id) {
      if (currentView !== 'edit') return;
      e.preventDefault();

      const tb = editTextBoxes.find(t => t.id === id);
      if (!tb) return;

      currentTextBoxId = id;
      textBoxX = tb.x;
      textBoxY = tb.y;
      textBoxStartX = tb.x;
      textBoxStartY = tb.y;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      coverWrapRect = document.getElementById('edit-cover-wrap').getBoundingClientRect();
      isDragging = true;
      e.target.closest('.edit-text-static').style.opacity = '0.8';
      document.getElementById('edit-trash').classList.add('visible');
    }

    function activateTextBox(id) {
      const tb = editTextBoxes.find(t => t.id === id);
      if (!tb) return;

      const textBox = document.getElementById('edit-text-box');
      const textInput = document.getElementById('edit-text-box-input');
      const textDisplay = document.getElementById('edit-text-box-display');

      // Save current text box first if there's one active
      if (textBox.style.display !== 'none' && currentTextBoxId !== null && currentTextBoxId !== id) {
        saveCurrentTextBoxToArray();
      }

      // Re-render all static text boxes (to show the previously active one)
      renderEditTextBoxes();

      // Hide the static element for the one we're activating
      const staticEl = document.querySelector(`.edit-text-static[data-id="${id}"]`);
      if (staticEl) staticEl.style.display = 'none';

      // Show active text box
      currentTextBoxId = id;
      textBoxX = tb.x;
      textBoxY = tb.y;
      textInput.value = tb.text;
      textDisplay.textContent = tb.text;
      textBox.style.display = 'block';
      textBox.style.left = tb.x + 'px';
      textBox.style.top = tb.y + 'px';

      // Apply colors
      textBox.style.backgroundColor = tb.color || '#ffffff';
      const textColor = tb.textColor || (isLightColor(tb.color || '#ffffff') ? '#1a1a1a' : '#ffffff');
      textBox.style.color = textColor;

      // Show color toolbar
      showColorToolbar();

      showEditDisplayMode();
    }

    function handleEditCoverTap(e) {
      if (currentView !== 'edit') return;

      // Ignore if tapping on text box or save button
      if (e.target.closest('.edit-text-box')) return;
      if (e.target.closest('.edit-save-btn')) return;

      const textBox = document.getElementById('edit-text-box');
      const textInput = document.getElementById('edit-text-box-input');
      const coverWrap = document.getElementById('edit-cover-wrap');

      // If currently editing, exit edit mode (blur handles the rest)
      if (isEditing) {
        textInput.blur();
        return;
      }

      // If active text box is visible, save it and hide it first
      if (textBox.style.display !== 'none') {
        saveCurrentTextBoxToArray();
        textBox.style.display = 'none';
        textInput.value = '';
        document.getElementById('edit-text-box-display').textContent = '';
        renderEditTextBoxes();
        hideColorToolbar();
      }

      // Create new text box at tap position
      const rect = coverWrap.getBoundingClientRect();
      textBoxX = e.clientX - rect.left - 25;
      textBoxY = e.clientY - rect.top - 12;

      // Constrain position
      textBoxX = Math.max(10, Math.min(textBoxX, rect.width - 60));
      textBoxY = Math.max(60, Math.min(textBoxY, rect.height - 100));

      // Generate new ID for this text box
      const maxId = editTextBoxes.reduce((max, tb) => Math.max(max, tb.id), -1);
      currentTextBoxId = maxId + 1;

      textBox.style.left = textBoxX + 'px';
      textBox.style.top = textBoxY + 'px';
      textBox.style.display = 'block';
      textBox.style.backgroundColor = '#ffffff';
      textBox.style.color = '#1a1a1a';

      // Set small initial size for empty text box
      textInput.style.width = '2px';
      textInput.style.height = '22px';
      textInput.style.minWidth = '0';

      // Show color toolbar
      showColorToolbar();

      // Enter edit mode
      showEditInputMode();
      textInput.focus();
    }

    function showEditInputMode() {
      const textBox = document.getElementById('edit-text-box');
      const textInput = document.getElementById('edit-text-box-input');
      const textDisplay = document.getElementById('edit-text-box-display');

      isEditing = true;
      textBox.classList.add('editing');
      textBox.classList.remove('draggable');

      // Only set dimensions if there's existing content
      if (textInput.value.trim()) {
        const displayRect = textDisplay.getBoundingClientRect();
        const currentWidth = displayRect.width;
        const currentHeight = displayRect.height || 22;
        textInput.style.width = currentWidth + 'px';
        textInput.style.height = currentHeight + 'px';
      }
      textInput.style.minWidth = '0';

      textInput.style.display = 'block';
      textDisplay.style.display = 'none';
    }

    function showEditDisplayMode() {
      const textBox = document.getElementById('edit-text-box');
      const textInput = document.getElementById('edit-text-box-input');
      const textDisplay = document.getElementById('edit-text-box-display');

      isEditing = false;
      textBox.classList.remove('editing');
      textBox.classList.add('draggable');
      textInput.style.display = 'none';
      textDisplay.style.display = 'block';
      textDisplay.textContent = textInput.value;

      // Reset textarea size constraints
      textInput.style.width = '';
      textInput.style.height = '';
    }

    function autoGrowTextarea() {
      const textInput = document.getElementById('edit-text-box-input');
      const textBox = document.getElementById('edit-text-box');
      const coverWrap = document.getElementById('edit-cover-wrap');

      // Calculate max width (container width minus margins and padding)
      const containerWidth = coverWrap.offsetWidth;
      const maxWidth = containerWidth - 20 - 28; // 10px margin each side, 28px padding

      // Create a temporary span to measure text width
      const measureSpan = document.createElement('span');
      measureSpan.style.cssText = `
        font-family: 'Courier Prime', 'Courier New', Courier, monospace;
        font-size: 16px;
        letter-spacing: 0.5px;
        white-space: pre;
        visibility: hidden;
        position: absolute;
      `;
      measureSpan.textContent = textInput.value || ' ';
      document.body.appendChild(measureSpan);

      // Get measured width and apply (with some buffer)
      let newWidth = Math.min(measureSpan.offsetWidth + 4, maxWidth);
      newWidth = Math.max(newWidth, 2); // minimum width

      document.body.removeChild(measureSpan);

      textInput.style.width = newWidth + 'px';

      // Only grow height for multiline, keep single line consistent
      const lineHeight = 22;
      const lines = Math.max(1, Math.ceil(textInput.scrollHeight / lineHeight));
      textInput.style.height = (lines * lineHeight) + 'px';
    }

    function handleEditTextFocus() {
      // Just mark as editing, no visual changes
      isEditing = true;
    }

    function handleEditTextBoxClick(e) {
      if (currentView !== 'edit') return;
      // If not currently editing, enter edit mode
      if (!isEditing) {
        e.stopPropagation();
        showEditInputMode();
        document.getElementById('edit-text-box-input').focus();
      }
    }

    function handleEditTextBlur() {
      const textInput = document.getElementById('edit-text-box-input');
      const textBox = document.getElementById('edit-text-box');

      isEditing = false;

      if (textInput.value.trim()) {
        showEditDisplayMode();
        // Save the current text box to the array
        saveCurrentTextBoxToArray();
        // Hide active box and render all as static
        textBox.style.display = 'none';
        textInput.value = '';
        document.getElementById('edit-text-box-display').textContent = '';
        renderEditTextBoxes();
      } else {
        // No text, hide the box and remove from array if it existed
        if (currentTextBoxId !== null) {
          editTextBoxes = editTextBoxes.filter(tb => tb.id !== currentTextBoxId);
        }
        textBox.style.display = 'none';
        currentTextBoxId = null;
      }
    }

    // Save the currently active text box to editTextBoxes array
    function saveCurrentTextBoxToArray() {
      if (currentTextBoxId === null) return;

      const textInput = document.getElementById('edit-text-box-input');
      const text = textInput.value.trim();

      if (!text) return;

      const existingIndex = editTextBoxes.findIndex(tb => tb.id === currentTextBoxId);

      if (existingIndex !== -1) {
        // Update existing text box
        editTextBoxes[existingIndex].text = text;
        editTextBoxes[existingIndex].x = textBoxX;
        editTextBoxes[existingIndex].y = textBoxY;
      } else {
        // Add new text box
        editTextBoxes.push({
          id: currentTextBoxId,
          text: text,
          x: textBoxX,
          y: textBoxY,
          color: '#ffffff',
          textColor: null
        });
      }
    }

    // Color picker functions
    function extractColorsFromCover(img) {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const size = 50;
        canvas.width = size;
        canvas.height = size;
        ctx.drawImage(img, 0, 0, size, size);

        const imageData = ctx.getImageData(0, 0, size, size).data;
        const colorCounts = {};

        for (let i = 0; i < imageData.length; i += 16) {
          const r = Math.round(imageData[i] / 32) * 32;
          const g = Math.round(imageData[i + 1] / 32) * 32;
          const b = Math.round(imageData[i + 2] / 32) * 32;
          const hex = rgbToHex(r, g, b);
          colorCounts[hex] = (colorCounts[hex] || 0) + 1;
        }

        extractedColors = Object.entries(colorCounts)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 6)
          .map(([color]) => color);

        renderColorSwatches();
      } catch (e) {
        extractedColors = [];
        renderColorSwatches();
      }
    }

    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => {
        const hex = Math.min(255, Math.max(0, x)).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }

    function renderColorSwatches() {
      const paletteContainer = document.getElementById('palette-colors');

      paletteContainer.innerHTML = appPalette.map(color =>
        `<div class="color-swatch ${isLightColor(color) ? 'light' : ''}" style="background: ${color}" onclick="applyColor('${color}')"></div>`
      ).join('');
    }

    function isLightColor(hex) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      return brightness > 180;
    }

    function toggleColorPicker(mode) {
      const picker = document.getElementById('color-picker');
      const bgBtn = document.getElementById('bg-color-btn');
      const textBtn = document.getElementById('text-color-btn');

      // If eyedropper is active, switch its mode instead
      if (eyedropperActive) {
        eyedropperMode = mode;
        bgBtn.classList.toggle('active', mode === 'bg');
        textBtn.classList.toggle('active', mode === 'text');
        return;
      }

      if (colorPickerMode === mode) {
        hideColorPicker();
      } else {
        colorPickerMode = mode;
        picker.classList.add('visible');
        bgBtn.classList.toggle('active', mode === 'bg');
        textBtn.classList.toggle('active', mode === 'text');
      }
    }

    function hideColorPicker() {
      colorPickerMode = null;
      document.getElementById('color-picker').classList.remove('visible');
      document.getElementById('bg-color-btn').classList.remove('active');
      document.getElementById('text-color-btn').classList.remove('active');
    }

    function applyColor(color) {
      if (currentTextBoxId === null) {
        hideColorPicker();
        return;
      }

      const tb = editTextBoxes.find(t => t.id === currentTextBoxId);
      if (!tb) return;

      if (colorPickerMode === 'bg') {
        tb.color = color;
      } else if (colorPickerMode === 'text') {
        tb.textColor = color;
      }

      // Update active text box display
      const textBox = document.getElementById('edit-text-box');
      if (textBox.style.display !== 'none') {
        if (colorPickerMode === 'bg') {
          textBox.style.backgroundColor = color;
          // Auto-set text color if not manually set
          if (!tb.textColor) {
            const autoTextColor = isLightColor(color) ? '#1a1a1a' : '#ffffff';
            textBox.style.color = autoTextColor;
          }
        } else if (colorPickerMode === 'text') {
          textBox.style.color = color;
        }
      }

      // Update static text box if visible
      const staticEl = document.querySelector(`.edit-text-static[data-id="${currentTextBoxId}"]`);
      if (staticEl) {
        if (colorPickerMode === 'bg') {
          staticEl.style.backgroundColor = color;
          if (!tb.textColor) {
            staticEl.style.color = isLightColor(color) ? '#1a1a1a' : '#ffffff';
          }
        } else if (colorPickerMode === 'text') {
          staticEl.style.color = color;
        }
      }

      hideColorPicker();
    }

    function showColorToolbar() {
      document.getElementById('color-toolbar').classList.add('visible');
    }

    function hideColorToolbar() {
      document.getElementById('color-toolbar').classList.remove('visible');
      hideColorPicker();
      hideEyedropper();
    }

    // Eyedropper functions
    function toggleEyedropper() {
      if (eyedropperActive) {
        hideEyedropper();
      } else {
        showEyedropper();
      }
    }

    function showEyedropper() {
      // Capture the current color picker mode before hiding it
      if (colorPickerMode) {
        eyedropperMode = colorPickerMode;
      }
      hideColorPicker();
      eyedropperActive = true;

      const overlay = document.getElementById('eyedropper-overlay');
      const eyedropperBtn = document.getElementById('eyedropper-btn');
      const bgBtn = document.getElementById('bg-color-btn');
      const textBtn = document.getElementById('text-color-btn');

      overlay.classList.add('active');
      eyedropperBtn.classList.add('active');

      // Highlight current mode button
      bgBtn.classList.toggle('active', eyedropperMode === 'bg');
      textBtn.classList.toggle('active', eyedropperMode === 'text');

      // Create canvas from cover image for color picking
      const img = document.getElementById('edit-cover');
      eyedropperCanvas = document.createElement('canvas');
      eyedropperCtx = eyedropperCanvas.getContext('2d');
      eyedropperCanvas.width = img.naturalWidth || img.width;
      eyedropperCanvas.height = img.naturalHeight || img.height;

      try {
        eyedropperCtx.drawImage(img, 0, 0);
      } catch (e) {
        console.log('Could not draw image to canvas');
      }

      // Add click handler to overlay
      overlay.addEventListener('click', handleEyedropperClick);
      overlay.addEventListener('touchend', handleEyedropperTouch);
    }

    function hideEyedropper() {
      eyedropperActive = false;

      const overlay = document.getElementById('eyedropper-overlay');
      const eyedropperBtn = document.getElementById('eyedropper-btn');
      const bgBtn = document.getElementById('bg-color-btn');
      const textBtn = document.getElementById('text-color-btn');

      overlay.classList.remove('active');
      eyedropperBtn.classList.remove('active');
      bgBtn.classList.remove('active');
      textBtn.classList.remove('active');

      overlay.removeEventListener('click', handleEyedropperClick);
      overlay.removeEventListener('touchend', handleEyedropperTouch);

      eyedropperCanvas = null;
      eyedropperCtx = null;
    }

    function handleEyedropperClick(e) {
      pickColorAt(e.clientX, e.clientY);
    }

    function handleEyedropperTouch(e) {
      if (e.changedTouches && e.changedTouches.length > 0) {
        const touch = e.changedTouches[0];
        pickColorAt(touch.clientX, touch.clientY);
      }
    }

    function pickColorAt(clientX, clientY) {
      if (!eyedropperCanvas || !eyedropperCtx) {
        return;
      }

      const img = document.getElementById('edit-cover');
      const imgRect = img.getBoundingClientRect();

      // Check if click is on the cover image - if outside, close eyedropper
      if (clientX < imgRect.left || clientX > imgRect.right ||
          clientY < imgRect.top || clientY > imgRect.bottom) {
        hideEyedropper();
        return;
      }

      // Calculate position on the canvas
      const scaleX = eyedropperCanvas.width / imgRect.width;
      const scaleY = eyedropperCanvas.height / imgRect.height;
      const canvasX = Math.floor((clientX - imgRect.left) * scaleX);
      const canvasY = Math.floor((clientY - imgRect.top) * scaleY);

      try {
        const pixel = eyedropperCtx.getImageData(canvasX, canvasY, 1, 1).data;
        const color = rgbToHex(pixel[0], pixel[1], pixel[2]);

        // Apply color to current text box based on eyedropper mode
        if (currentTextBoxId !== null) {
          const tb = editTextBoxes.find(t => t.id === currentTextBoxId);
          if (tb) {
            const textBox = document.getElementById('edit-text-box');
            const staticEl = document.querySelector(`.edit-text-static[data-id="${currentTextBoxId}"]`);

            if (eyedropperMode === 'bg') {
              tb.color = color;

              if (textBox.style.display !== 'none') {
                textBox.style.backgroundColor = color;
                if (!tb.textColor) {
                  textBox.style.color = isLightColor(color) ? '#1a1a1a' : '#ffffff';
                }
              }
              if (staticEl) {
                staticEl.style.backgroundColor = color;
                if (!tb.textColor) {
                  staticEl.style.color = isLightColor(color) ? '#1a1a1a' : '#ffffff';
                }
              }
            } else if (eyedropperMode === 'text') {
              tb.textColor = color;

              if (textBox.style.display !== 'none') {
                textBox.style.color = color;
              }
              if (staticEl) {
                staticEl.style.color = color;
              }
            }
          }
        }
      } catch (e) {
        console.log('Could not pick color:', e);
      }
      // Keep eyedropper active - user can click again or tap outside cover to close
    }

    // Text box dragging (touch)
    function handleEditTextBoxTouchStart(e) {
      if (currentView !== 'edit') return;
      if (isEditing) return;

      const touch = e.touches[0];
      const textBox = document.getElementById('edit-text-box');
      const textInput = document.getElementById('edit-text-box-input');

      coverWrapRect = document.getElementById('edit-cover-wrap').getBoundingClientRect();
      textBoxStartX = textBoxX;
      textBoxStartY = textBoxY;
      dragStartX = touch.clientX;
      dragStartY = touch.clientY;

      // Start long press timer for drag
      longPressTimer = setTimeout(() => {
        isDragging = true;
        textBox.style.opacity = '0.8';
        // Show trash if text box has content
        if (textInput.value.trim()) {
          document.getElementById('edit-trash').classList.add('visible');
        }
      }, 150);
    }

    function handleEditTextBoxTouchMove(e) {
      if (currentView !== 'edit') return;

      const textInput = document.getElementById('edit-text-box-input');

      // If moved, clear long press and start dragging immediately
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
        isDragging = true;
        document.getElementById('edit-text-box').style.opacity = '0.8';
        // Show trash if text box has content
        if (textInput.value.trim()) {
          document.getElementById('edit-trash').classList.add('visible');
        }
      }

      if (!isDragging) return;
      e.preventDefault();

      const touch = e.touches[0];
      const deltaX = touch.clientX - dragStartX;
      const deltaY = touch.clientY - dragStartY;

      let newX = textBoxStartX + deltaX;
      let newY = textBoxStartY + deltaY;

      // Constrain to cover area
      const textBox = document.getElementById('edit-text-box');
      const maxX = coverWrapRect.width - textBox.offsetWidth - 10;
      const maxY = coverWrapRect.height - textBox.offsetHeight - 80;
      newX = Math.max(10, Math.min(newX, maxX));
      newY = Math.max(10, Math.min(newY, maxY));

      textBoxX = newX;
      textBoxY = newY;
      textBox.style.left = textBoxX + 'px';
      textBox.style.top = textBoxY + 'px';

      // Check if over trash
      checkTrashHover(touch.clientX, touch.clientY);
    }

    function handleEditTextBoxTouchEnd(e) {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }

      const textBox = document.getElementById('edit-text-box');
      const trash = document.getElementById('edit-trash');

      // Check if dropped on trash
      if (isDragging && trash.classList.contains('active')) {
        // Delete the text box
        deleteTextBox();
      }

      textBox.style.opacity = '1';
      trash.classList.remove('visible', 'active');

      if (!isDragging && !isEditing) {
        // It was a tap, enter edit mode
        showEditInputMode();
        document.getElementById('edit-text-box-input').focus();
      }

      isDragging = false;
      coverWrapRect = null;
    }

    // Text box dragging (mouse)
    function handleEditTextBoxMouseDown(e) {
      if (currentView !== 'edit') return;
      if (isEditing) return;
      e.preventDefault();

      const textInput = document.getElementById('edit-text-box-input');

      coverWrapRect = document.getElementById('edit-cover-wrap').getBoundingClientRect();
      textBoxStartX = textBoxX;
      textBoxStartY = textBoxY;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      isDragging = true;
      document.getElementById('edit-text-box').style.opacity = '0.8';

      // Show trash if text box has content
      if (textInput.value.trim()) {
        document.getElementById('edit-trash').classList.add('visible');
      }
    }

    function handleEditTextBoxMouseMove(e) {
      if (!isDragging || !coverWrapRect) return;

      const deltaX = e.clientX - dragStartX;
      const deltaY = e.clientY - dragStartY;

      let newX = textBoxStartX + deltaX;
      let newY = textBoxStartY + deltaY;

      // Check if we're dragging a static text box or the active one
      const staticEl = document.querySelector(`.edit-text-static[data-id="${currentTextBoxId}"]`);
      const textBox = document.getElementById('edit-text-box');
      const el = staticEl || textBox;

      const maxX = coverWrapRect.width - el.offsetWidth - 10;
      const maxY = coverWrapRect.height - el.offsetHeight - 80;
      newX = Math.max(10, Math.min(newX, maxX));
      newY = Math.max(10, Math.min(newY, maxY));

      textBoxX = newX;
      textBoxY = newY;
      el.style.left = textBoxX + 'px';
      el.style.top = textBoxY + 'px';

      // Update position in array for static text boxes
      if (staticEl && currentTextBoxId !== null) {
        const tb = editTextBoxes.find(t => t.id === currentTextBoxId);
        if (tb) {
          tb.x = newX;
          tb.y = newY;
        }
      }

      // Check if over trash
      checkTrashHover(e.clientX, e.clientY);
    }

    function handleEditTextBoxMouseUp(e) {
      const textBox = document.getElementById('edit-text-box');
      const trash = document.getElementById('edit-trash');
      const staticEl = document.querySelector(`.edit-text-static[data-id="${currentTextBoxId}"]`);

      // Check if dropped on trash
      if (isDragging && trash.classList.contains('active')) {
        if (staticEl) {
          // Delete static text box
          editTextBoxes = editTextBoxes.filter(tb => tb.id !== currentTextBoxId);
          staticEl.remove();
        } else {
          deleteTextBox();
        }
      }

      if (isDragging) {
        if (staticEl) {
          staticEl.style.opacity = '1';
        } else {
          textBox.style.opacity = '1';
        }
      }

      trash.classList.remove('visible', 'active');
      isDragging = false;
      coverWrapRect = null;
    }

    function checkTrashHover(clientX, clientY) {
      const trash = document.getElementById('edit-trash');
      const trashRect = trash.getBoundingClientRect();

      // Check if pointer is over trash
      const isOverTrash = clientX >= trashRect.left &&
                          clientX <= trashRect.right &&
                          clientY >= trashRect.top &&
                          clientY <= trashRect.bottom;

      if (isOverTrash) {
        trash.classList.add('active');
      } else {
        trash.classList.remove('active');
      }
    }

    function deleteTextBox() {
      const textBox = document.getElementById('edit-text-box');
      const textInput = document.getElementById('edit-text-box-input');
      const textDisplay = document.getElementById('edit-text-box-display');

      textInput.value = '';
      textDisplay.textContent = '';
      textBox.style.display = 'none';
      isEditing = false;
    }

    // Save button - save and show Book View
    function handleSave() {
      if (!selectedBook) return;

      // Save any active text box to the array first
      const textBox = document.getElementById('edit-text-box');
      if (textBox.style.display !== 'none') {
        saveCurrentTextBoxToArray();
      }

      // Hide color toolbar
      hideColorToolbar();

      // Convert editTextBoxes to the storage format
      const textBoxes = editTextBoxes.map(tb => ({
        text: tb.text,
        x: Math.round(tb.x),
        y: Math.round(tb.y),
        color: tb.color || '#ffffff',
        textColor: tb.textColor || null
      }));

      // For backward compatibility, also set reflection to first text box
      const reflection = textBoxes.length > 0 ? textBoxes[0].text : '';

      const updatedBook = updateBook(selectedBook.id, {
        textBoxes,
        reflection,
        textBoxColor: textBoxes.length > 0 ? textBoxes[0].color : '#ffffff',
        textBoxX: textBoxes.length > 0 ? textBoxes[0].x : 0,
        textBoxY: textBoxes.length > 0 ? textBoxes[0].y : 0,
        yearRead: selectedBook.yearRead || new Date().getFullYear().toString()
      });

      // Go to Book View to show the result (no animation)
      showBookView(updatedBook || selectedBook, true, false);
    }

    // Search books (Open Library API + Google Books for Chinese support)
    async function searchBooks() {
      const query = document.getElementById('search-input').value.trim();
      if (!query) return;

      const resultsContainer = document.getElementById('search-results');
      resultsContainer.innerHTML = '<div class="search-message">searching...</div>';

      // Detect if query contains Chinese characters (including Traditional Chinese range)
      const hasChinese = /[\u4e00-\u9fff\u3400-\u4dbf\u3100-\u312F\uF900-\uFAFF]/.test(query);

      // Helper to parse Google Books results
      const parseGoogleBooks = (data) => {
        if (!data.items || data.items.length === 0) return [];
        return data.items.map(item => {
          const info = item.volumeInfo;
          let summary = info.description || '';
          if (summary.length > 300) {
            summary = summary.substring(0, 300).trim() + '...';
          }
          return {
            title: info.title || 'Unknown Title',
            author: info.authors?.join(', ') || 'Unknown Author',
            thumbUrl: info.imageLinks?.thumbnail?.replace('http:', 'https:') || '',
            coverUrl: info.imageLinks?.thumbnail?.replace('http:', 'https:').replace('zoom=1', 'zoom=2') || '',
            summary: summary
          };
        });
      };

      try {
        let results = [];

        if (hasChinese) {
          // Search Google Books without language restriction for better Traditional Chinese coverage
          const [googleResponse1, googleResponse2] = await Promise.all([
            fetch(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=20&printType=books`),
            fetch(`https://www.googleapis.com/books/v1/volumes?q=intitle:${encodeURIComponent(query)}&maxResults=15&printType=books`)
          ]);

          const [googleData1, googleData2] = await Promise.all([
            googleResponse1.json(),
            googleResponse2.json()
          ]);

          results = [...parseGoogleBooks(googleData1), ...parseGoogleBooks(googleData2)];
        } else {
          // For non-Chinese queries, search Google Books as well
          const googleResponse = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=10&printType=books`);
          const googleData = await googleResponse.json();
          results = parseGoogleBooks(googleData);
        }

        // Also search Open Library (works well for English and some Chinese)
        const openLibResponse = await fetch(`https://openlibrary.org/search.json?q=${encodeURIComponent(query)}&limit=10`);
        const openLibData = await openLibResponse.json();

        if (openLibData.docs && openLibData.docs.length > 0) {
          const openLibResults = openLibData.docs.map(doc => ({
            title: doc.title || 'Unknown Title',
            author: doc.author_name?.join(', ') || 'Unknown Author',
            thumbUrl: doc.cover_i ? `https://covers.openlibrary.org/b/id/${doc.cover_i}-M.jpg` : '',
            coverUrl: doc.cover_i ? `https://covers.openlibrary.org/b/id/${doc.cover_i}-L.jpg` : '',
            summary: doc.first_sentence?.join(' ') || '',
            openLibraryKey: doc.key || ''
          }));

          // Merge results, prioritizing Chinese results for Chinese queries
          if (hasChinese) {
            results = [...results, ...openLibResults];
          } else {
            results = [...openLibResults, ...results];
          }
        }

        // Remove duplicates by title (rough match)
        const seen = new Set();
        results = results.filter(r => {
          const key = r.title.toLowerCase().substring(0, 20);
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).slice(0, 20);

        if (results.length === 0) {
          resultsContainer.innerHTML = '<div class="search-message">no books found. try a different search.</div>';
          return;
        }

        resultsContainer.innerHTML = results.map(book => {
          const thumbUrl = book.thumbUrl || 'https://via.placeholder.com/50x75/f0f0f0/999?text=No+Cover';

          return `
            <div class="result-item" onclick="addBookFromSearch(${JSON.stringify({
              title: book.title,
              author: book.author,
              coverUrl: book.coverUrl,
              summary: book.summary || ''
            }).replace(/"/g, '&quot;')})">
              <img src="${thumbUrl}" alt="${book.title}" class="result-cover" onerror="this.src='https://via.placeholder.com/50x75/f0f0f0/999?text=No+Cover'">
              <div class="result-info">
                <div class="result-title">${book.title}</div>
                <div class="result-author">${book.author}</div>
              </div>
            </div>
          `;
        }).join('');
      } catch (error) {
        resultsContainer.innerHTML = '<div class="search-message">error searching. please try again.</div>';
        console.error('Search error:', error);
      }
    }

    function handleSearchKeypress(event) {
      if (event.key === 'Enter') searchBooks();
    }

    function addBookFromSearch(bookData) {
      const book = addBook({
        title: bookData.title,
        author: bookData.author,
        coverUrl: bookData.coverUrl || '',
        summary: bookData.summary || ''
      });
      showEditView(book);
    }

    // Manual form
    function handleManualSubmit() {
      const title = document.getElementById('manual-title').value.trim();
      const author = document.getElementById('manual-author').value.trim();
      const yearRead = document.getElementById('manual-year').value.trim();
      const coverUrl = document.getElementById('cover-url-input').value.trim();

      if (!title) {
        alert('please enter a book title.');
        return;
      }

      // Use uploaded image, then URL, then placeholder
      let finalCoverUrl = uploadedCoverBase64 || coverUrl || 'https://via.placeholder.com/128x192/f0f0f0/999?text=No+Cover';

      const book = addBook({
        title,
        author: author || 'Unknown Author',
        coverUrl: finalCoverUrl,
        yearRead: yearRead || new Date().getFullYear().toString()
      });

      showEditView(book);
    }

    function handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        uploadedCoverBase64 = e.target.result;
        const container = document.getElementById('cover-preview-container');
        container.innerHTML = `<img src="${uploadedCoverBase64}" alt="Cover preview" class="cover-preview">`;
        container.classList.remove('cover-placeholder');
        // Clear URL input when image is uploaded
        document.getElementById('cover-url-input').value = '';
      };
      reader.readAsDataURL(file);
    }

    function handleCoverUrlInput(event) {
      const url = event.target.value.trim();
      if (!url) return;

      // Clear uploaded image when URL is entered
      uploadedCoverBase64 = null;
      const container = document.getElementById('cover-preview-container');
      container.innerHTML = `<img src="${url}" alt="Cover preview" class="cover-preview" onerror="this.parentElement.innerHTML='<span class=\\'cover-placeholder-icon\\'>+</span><span class=\\'cover-placeholder-text\\'>upload</span>';this.parentElement.classList.add('cover-placeholder');">`;
      container.classList.remove('cover-placeholder');
    }

    function resetAddForm() {
      document.getElementById('search-input').value = '';
      document.getElementById('search-results').innerHTML = '<div class="search-message">search for a book above</div>';
      document.getElementById('manual-title').value = '';
      document.getElementById('manual-author').value = '';
      document.getElementById('manual-year').value = '';
      document.getElementById('cover-url-input').value = '';
      uploadedCoverBase64 = null;

      const container = document.getElementById('cover-preview-container');
      container.innerHTML = '<span class="cover-placeholder-icon">+</span><span class="cover-placeholder-text">upload</span>';
      container.classList.add('cover-placeholder');

      switchTab('search');
    }


    // Delete modal
    function showDeleteModal() {
      document.getElementById('delete-modal').classList.add('active');
    }

    function hideDeleteModal() {
      document.getElementById('delete-modal').classList.remove('active');
    }

    function confirmDelete() {
      if (!selectedBook) return;
      deleteBook(selectedBook.id);
      hideDeleteModal();
      showHomeView();
    }
  </script>
</body>
</html>
