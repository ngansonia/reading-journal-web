<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-visual">
  <title>Between Pages</title>

  <!-- PWA Meta Tags -->
  <meta name="description" content="A beautiful reading journal to capture thoughts left between the pages">
  <meta name="theme-color" content="#5c4d3d">
  <meta name="background-color" content="#faf8f5">

  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json">

  <!-- iOS PWA Support -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Between Pages">

  <!-- iOS Icons -->
  <link rel="apple-touch-icon" href="icons/icon-152.png">
  <link rel="apple-touch-icon" sizes="72x72" href="icons/icon-72.png">
  <link rel="apple-touch-icon" sizes="96x96" href="icons/icon-96.png">
  <link rel="apple-touch-icon" sizes="128x128" href="icons/icon-128.png">
  <link rel="apple-touch-icon" sizes="144x144" href="icons/icon-144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="icons/icon-152.png">
  <link rel="apple-touch-icon" sizes="192x192" href="icons/icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-96.png">

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* PWA: Prevent overscroll/bounce effect */
    html {
      overflow: hidden;
      height: 100%;
    }

    body {
      font-family: 'Courier Prime', 'Courier New', Courier, monospace;
      background-color: #faf8f5;
      color: #3d3428;
      min-height: 100vh;
      letter-spacing: 0.5px;
      overflow: auto;
      height: 100%;
      -webkit-overflow-scrolling: touch;
      /* PWA: Handle safe areas for notched devices */
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
    }

    .container {
      max-width: 480px;
      margin: 0 auto;
      min-height: 100vh;
    }

    /* Views */
    .view {
      display: none;
      min-height: 100vh;
    }

    .view.active {
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      padding: 16px 20px;
      background: #faf8f5;
      border-bottom: 1px solid #e8e4df;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .header-title {
      font-size: 14px;
      font-weight: 400;
      letter-spacing: 2px;
      text-transform: lowercase;
      color: #5c4d3d;
    }

    .back-btn {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      padding: 4px 8px;
      color: #5c4d3d;
    }

    /* Sticky Header (Home) - Slim Horizontal */
    .sticky-header {
      padding: 14px 20px;
      background: #faf8f5;
      position: sticky;
      top: 0;
      z-index: 40;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid #ebe7e2;
    }

    .sticky-header::before {
      content: '';
      position: absolute;
      bottom: 100%;
      left: 0;
      right: 0;
      height: env(safe-area-inset-top);
      background: #faf8f5;
    }

    .logo-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .header-divider {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 1px;
      height: 28px;
      background: #ddd6cc;
    }

    .logo-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      width: 24px;
      height: 28px;
    }

    .logo-icon::before,
    .logo-icon::after {
      content: '';
      width: 2px;
      height: 22px;
      background: linear-gradient(to bottom, transparent, #8b7355 20%, #8b7355 80%, transparent);
      border-radius: 1px;
    }

    .logo-icon::after {
      background: linear-gradient(to bottom, transparent, #a89078 20%, #a89078 80%, transparent);
    }

    .sticky-header h1 {
      font-size: 14px;
      font-weight: 400;
      letter-spacing: 4px;
      color: #5c4d3d;
      text-transform: lowercase;
      display: flex;
      flex-direction: column;
      line-height: 1.3;
    }

    .sticky-header h1 span {
      display: block;
    }

    .tagline {
      font-size: 7.5px;
      color: #b8a99a;
      letter-spacing: 0.5px;
      font-style: italic;
      white-space: nowrap;
      text-align: right;
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 0;
    }

    /* Empty State */
    .empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 40px;
      text-align: center;
    }

    .empty-state h2 {
      font-size: 18px;
      font-weight: 400;
      letter-spacing: 2px;
      margin-bottom: 12px;
      color: #5c4d3d;
    }

    .empty-state p {
      font-size: 13px;
      color: #a89078;
      letter-spacing: 1px;
    }

    /* Timeline / Year Sections */
    .timeline {
      flex: 1;
      padding: 0 20px 100px;
      overflow-y: auto;
      background: #faf8f5;
    }

    .year-header {
      display: flex;
      align-items: center;
      margin: 28px 0 20px;
    }

    .year-line {
      flex: 1;
      height: 1px;
      background: #d4cec4;
    }

    .year-text {
      font-size: 16px;
      letter-spacing: 4px;
      margin: 0 16px;
      color: #8b7355;
    }

    /* Floating year indicator */
    .year-indicator {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%) translateY(-10px);
      background: rgba(212, 206, 196, 0.85);
      color: #fff;
      padding: 6px 16px;
      border-radius: 20px;
      font-size: 14px;
      letter-spacing: 3px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease, transform 0.3s ease;
      z-index: 50;
    }

    .year-indicator.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    /* Book Grid */
    .year-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      justify-content: space-between;
    }

    .book-card {
      width: calc(50% - 8px);
      cursor: pointer;
      margin-bottom: 12px;
      transition: transform 0.2s;
    }

    .book-card:hover {
      transform: translateY(-2px);
    }

    .card-inner {
      position: relative;
      box-shadow: 0 2px 8px rgba(92, 77, 61, 0.1);
    }

    .card-cover {
      width: 100%;
      aspect-ratio: 2 / 3;
      background: #e8e4df;
      object-fit: cover;
      display: block;
    }

    .card-title {
      margin-top: 10px;
      font-size: 12px;
      letter-spacing: 0.5px;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      color: #3d3428;
    }

    .card-author {
      font-size: 10px;
      color: #8b7355;
      margin-top: 2px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* FAB Button */
    .fab {
      position: fixed;
      bottom: 36px;
      right: 24px;
      width: 56px;
      height: 56px;
      background: #5c4d3d;
      color: #faf8f5;
      border: none;
      font-size: 28px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: inherit;
      z-index: 50;
      border-radius: 50%;
      box-shadow: 0 4px 16px rgba(92, 77, 61, 0.3);
      transition: all 0.2s;
    }

    .fab:hover {
      background: #4a3e31;
      transform: scale(1.05);
    }

    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 1px solid #e8e4df;
      background: #faf8f5;
    }

    .tab {
      flex: 1;
      padding: 14px;
      border: none;
      background: transparent;
      font-family: inherit;
      font-size: 13px;
      letter-spacing: 2px;
      cursor: pointer;
      color: #a89078;
      text-transform: lowercase;
      transition: all 0.2s;
    }

    .tab.active {
      background: #5c4d3d;
      color: #faf8f5;
    }

    .tab:not(.active):hover {
      color: #5c4d3d;
    }

    /* Tab Content */
    .tab-content {
      display: none;
      flex: 1;
      flex-direction: column;
    }

    .tab-content.active {
      display: flex;
    }

    /* Search */
    .search-row {
      display: flex;
      padding: 20px;
      gap: 12px;
      background: #faf8f5;
    }

    .search-input {
      flex: 1;
      font-family: inherit;
      background: #fff;
      padding: 14px 16px;
      font-size: 14px;
      border: 1px solid #e8e4df;
      outline: none;
      color: #5c4d3d;
    }

    .search-input::placeholder {
      color: #c4b8a8;
    }

    .search-input:focus {
      border-color: #a89078;
    }

    .search-btn {
      background: #5c4d3d;
      color: #faf8f5;
      border: none;
      padding: 14px 20px;
      font-family: inherit;
      font-size: 14px;
      letter-spacing: 1px;
      cursor: pointer;
      text-transform: lowercase;
    }

    .search-btn:hover {
      background: #4a3e31;
    }

    /* Search Results */
    .search-results {
      flex: 1;
      padding: 0 20px 20px;
      overflow-y: auto;
      background: #faf8f5;
    }

    .result-item {
      display: flex;
      border-bottom: 1px solid #e8e4df;
      padding: 14px 0;
      cursor: pointer;
      transition: background 0.2s;
    }

    .result-item:hover {
      background: #f5f0ea;
    }

    .result-cover {
      width: 50px;
      height: 75px;
      background: #e8e4df;
      object-fit: cover;
    }

    .result-info {
      flex: 1;
      margin-left: 14px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .result-title {
      font-size: 13px;
      margin-bottom: 6px;
      color: #3d3428;
    }

    .result-author {
      font-size: 11px;
      color: #8b7355;
    }

    .search-message {
      text-align: center;
      padding: 40px 20px;
      color: #a89078;
      font-size: 13px;
      letter-spacing: 1px;
    }

    /* Form */
    .form {
      padding: 24px;
      flex: 1;
      overflow-y: auto;
      background: #faf8f5;
    }

    .form-input {
      width: 100%;
      font-family: inherit;
      background: #fff;
      padding: 14px 16px;
      font-size: 14px;
      border: 1px solid #e8e4df;
      outline: none;
      margin-bottom: 16px;
      color: #5c4d3d;
    }

    .form-input::placeholder {
      color: #c4b8a8;
    }

    .form-input:focus {
      border-color: #a89078;
    }

    /* Cover Section */
    .cover-section {
      margin: 20px 0;
    }

    .cover-label {
      font-size: 12px;
      color: #8b7355;
      letter-spacing: 1px;
      margin-bottom: 12px;
      display: block;
    }

    .cover-options {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .cover-picker {
      flex-shrink: 0;
    }

    .cover-preview {
      width: 80px;
      height: 120px;
      object-fit: cover;
      border-radius: 2px;
    }

    .cover-placeholder {
      width: 80px;
      height: 120px;
      background: #fff;
      border: 1px dashed #c4b8a8;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      color: #a89078;
      cursor: pointer;
      border-radius: 2px;
      transition: all 0.2s ease;
    }

    .cover-placeholder-icon {
      font-size: 24px;
      line-height: 1;
      margin-bottom: 4px;
    }

    .cover-placeholder-text {
      font-size: 10px;
      letter-spacing: 1px;
    }

    .cover-placeholder:hover {
      border-color: #8b7355;
      color: #8b7355;
      background: #faf8f5;
    }

    .cover-url-section {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .cover-or {
      font-size: 11px;
      color: #b8a99a;
      font-style: italic;
    }

    .cover-url-input {
      flex: 1;
      margin-bottom: 0;
      font-size: 12px;
      padding: 10px 12px;
    }

    #cover-input {
      display: none;
    }

    /* Submit Button */
    .save-btn {
      width: 100%;
      background: #5c4d3d;
      color: #faf8f5;
      border: none;
      padding: 16px;
      font-family: inherit;
      font-size: 14px;
      letter-spacing: 2px;
      cursor: pointer;
      margin-top: 20px;
      text-transform: lowercase;
    }

    .save-btn:hover {
      background: #4a3e31;
    }

    /* Edit View - Story-Style Editor */
    .edit-view-container {
      display: flex;
      flex-direction: column;
      background: #000;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 70;
    }

    .edit-cover-wrap {
      flex: 1;
      position: relative;
      overflow: hidden;
      /* iOS cover-jump fix, layer 1 of 3:
         Unlike overflow:hidden, overflow:clip does NOT create a scroll
         container — so iOS WebKit physically cannot scroll this element
         when it tries to bring a focused textarea into view.
         overflow:hidden is kept above as a fallback for iOS < 16 where
         clip is unsupported; layers 2 (preventScroll) and 3 (scroll
         listener) handle those older devices. */
      overflow: clip;
      background: #000;
      z-index: 5;
    }

    .edit-text-static {
      z-index: 15;
      touch-action: none;
      cursor: move;
    }

    .edit-cover-bg {
      position: absolute;
      top: -20px;
      left: -20px;
      right: -20px;
      bottom: -20px;
      background-size: cover;
      background-position: center;
      filter: blur(20px) brightness(0.4);
      z-index: 1;
    }

    .edit-cover {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: 100%;
      object-fit: contain;
      z-index: 2;
    }

    /* Trash icon for deleting text box */
    .edit-trash {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      width: 44px;
      height: 44px;
      background: rgba(0,0,0,0.4);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, transform 0.2s, background 0.2s;
      pointer-events: auto;
    }

    .edit-trash.visible {
      opacity: 1;
      visibility: visible;
    }

    .edit-trash.active {
      background: rgba(200, 80, 80, 0.8);
      transform: translateX(-50%) scale(1.2);
    }

    .edit-trash::before {
      content: '';
      width: 18px;
      height: 20px;
      border: 2px solid #fff;
      border-top: none;
      border-radius: 0 0 4px 4px;
      position: relative;
    }

    .edit-trash::after {
      content: '';
      position: absolute;
      top: 10px;
      width: 22px;
      height: 3px;
      background: #fff;
      border-radius: 2px;
    }

    /* Save button for Edit View */
    .edit-save-btn {
      position: absolute;
      bottom: 32px;
      left: 50%;
      transform: translateX(-50%);
      background: #5c4d3d;
      color: #faf8f5;
      border: none;
      padding: 14px 48px;
      font-family: inherit;
      font-size: 14px;
      letter-spacing: 2px;
      cursor: pointer;
      text-transform: lowercase;
      z-index: 50;
      pointer-events: auto;
      -webkit-tap-highlight-color: transparent;
    }

    .edit-save-btn:hover {
      background: #4a3e31;
    }

    /* Stories-Style Toolbar */
    .stories-toolbar {
      position: absolute;
      top: calc(16px + env(safe-area-inset-top));
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: 24px;
      z-index: 45;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    .stories-toolbar.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .toolbar-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: none;
      background: rgba(255, 255, 255, 0.15);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease, transform 0.2s ease;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      color: #fff;
    }

    .toolbar-btn:hover {
      background: rgba(255, 255, 255, 0.25);
    }

    .toolbar-btn:active {
      transform: scale(0.95);
    }

    .toolbar-btn.active {
      background: rgba(255, 255, 255, 0.9);
      color: #1a1a1a;
    }

    .toolbar-btn.done-btn {
      width: auto;
      padding: 0 16px;
      border-radius: 20px;
      font-family: inherit;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.5px;
    }

    .font-preview {
      font-size: 16px;
      font-weight: 600;
    }

    .color-indicator {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.5);
      background: #ffffff;
    }

    .highlight-icon {
      font-size: 16px;
      font-weight: 700;
      padding: 2px 4px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.3);
    }

    .toolbar-btn.highlight-off .highlight-icon {
      background: transparent;
      text-decoration: underline;
    }

    .eyedropper-icon {
      font-size: 18px;
    }

    /* Legacy color toolbar for backward compatibility */
    .color-toolbar {
      display: none;
    }

    /* Font Picker Dropdown */
    .font-picker {
      position: absolute;
      top: calc(70px + env(safe-area-inset-top));
      left: 50%;
      transform: translateX(-50%) translateY(-10px);
      background: rgba(255, 255, 255, 0.95);
      border-radius: 12px;
      padding: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      z-index: 46;
      opacity: 0;
      pointer-events: none;
      transition: all 0.2s ease;
      min-width: 160px;
    }

    .font-picker.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateX(-50%) translateY(0);
    }

    .font-option {
      padding: 10px 14px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.15s ease;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .font-option:hover {
      background: rgba(0, 0, 0, 0.05);
    }

    .font-option.selected {
      background: rgba(92, 77, 61, 0.15);
    }

    .font-option-preview {
      font-size: 18px;
      width: 28px;
      text-align: center;
    }

    .font-option-name {
      font-size: 13px;
      color: #5c4d3d;
    }

    /* Color Picker Dropdown */
    .color-picker {
      position: absolute;
      top: calc(70px + env(safe-area-inset-top));
      left: 50%;
      transform: translateX(-50%) translateY(-10px);
      background: rgba(255, 255, 255, 0.95);
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      z-index: 46;
      opacity: 0;
      pointer-events: none;
      transition: all 0.2s ease;
      min-width: 180px;
    }

    .color-picker.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateX(-50%) translateY(0);
    }

    .color-picker-section {
      margin-bottom: 12px;
    }

    .color-picker-section:last-child {
      margin-bottom: 0;
    }

    .color-picker-label {
      font-size: 9px;
      color: #8b7355;
      letter-spacing: 1px;
      text-transform: lowercase;
      display: block;
      margin-bottom: 8px;
    }

    .color-swatches {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .color-swatch {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
      transition: transform 0.15s ease, border-color 0.15s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }

    .color-swatch:hover {
      transform: scale(1.15);
    }

    .color-swatch.selected {
      border-color: #5c4d3d;
    }

    .color-swatch.light {
      border: 2px solid #e0e0e0;
    }

    .color-swatch.light:hover,
    .color-swatch.light.selected {
      border-color: #5c4d3d;
    }

    /* Eyedropper */
    .eyedropper-icon {
      font-size: 16px;
    }

    .eyedropper-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 30;
      cursor: crosshair;
      display: none;
    }

    .eyedropper-overlay.active {
      display: block;
      z-index: 50;
      touch-action: none;
    }

    .eyedropper-preview {
      position: fixed;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: 3px solid #fff;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      pointer-events: none;
      z-index: 100;
      display: none;
      transform: translate(-50%, -120%);
    }

    .eyedropper-preview.visible {
      display: block;
    }

    .eyedropper-preview::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 8px solid #fff;
    }

    /* Editable Text Box for Edit View */
    .edit-text-box {
      position: absolute;
      padding: 2px 14px;
      min-width: 100px;
      max-width: calc(100% - 20px);
      background: #ffffff;
      color: #1a1a1a;
      z-index: 15;
      touch-action: none;
      user-select: none;
    }

    .edit-text-box.editing {
      cursor: text;
      user-select: text;
    }

    .edit-text-box.draggable {
      cursor: move;
    }

    .edit-text-box.no-bg {
      background: transparent !important;
    }

    .edit-text-box-input {
      font-family: var(--text-box-font, 'Courier Prime', monospace);
      font-size: var(--text-box-font-size, 16px);
      line-height: 1.4;
      letter-spacing: 0.5px;
      border: none;
      outline: none;
      background: transparent;
      color: inherit;
      resize: none;
      overflow: hidden;
      display: block;
      caret-color: #d4c4a8;
      padding: 0;
      margin: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
      -webkit-text-size-adjust: 100%;
      -moz-text-size-adjust: 100%;
      text-size-adjust: 100%;
      box-sizing: border-box;
    }

    .edit-text-box-display {
      font-family: var(--text-box-font, 'Courier Prime', monospace);
      font-size: var(--text-box-font-size, 16px);
      line-height: 1.4;
      letter-spacing: 0.5px;
      white-space: pre-wrap;
      word-wrap: break-word;
      min-height: 22px;
      padding: 0;
      margin: 0;
    }


    /* Book View - Clean fullscreen display */
    .book-view-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 60;
      background: #000;
      overflow: hidden;
      animation: bookViewIn 0.35s ease forwards;
      touch-action: none;
    }

    .book-view-container.closing {
      animation: bookViewOut 0.5s ease-out forwards;
    }

    .book-view-container.swipe-transition {
      transition: transform 0.35s cubic-bezier(0.2, 0.9, 0.3, 1), border-radius 0.35s ease;
    }

    .book-view-container.swipe-exit {
      transition: transform 0.3s cubic-bezier(0.2, 0.9, 0.3, 1), opacity 0.3s ease-out, border-radius 0.3s ease;
    }

    #home-view.swipe-fade {
      transition: opacity 0.3s ease-out;
    }

    @keyframes bookViewIn {
      from {
        opacity: 0;
        transform: scale(0.98);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes bookViewOut {
      from {
        opacity: 1;
        transform: translateY(0);
      }
      to {
        opacity: 0;
        transform: translateY(100%);
      }
    }

    /* 3D Cube transition */
    #book-view {
      overflow: hidden;
      touch-action: none;
    }

    .cube-wrapper {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 61;
      overflow: hidden;
      opacity: 1;
      background: #000;
    }

    .cube-wrapper.cube-fade-out {
      opacity: 0;
      transition: opacity 0.18s ease-out;
    }

    .cube-scene {
      position: absolute;
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
      transform-origin: 50% 50%;
    }

    .cube-scene.cube-animate {
      transition: transform 0.4s cubic-bezier(0.33, 0, 0.2, 1);
    }

    .cube-face {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      background: #000;
      overflow: hidden;
      transform-origin: 50% 50%;
    }

    .cube-face .book-view-bg {
      position: absolute;
      top: -20px;
      left: -20px;
      right: -20px;
      bottom: -20px;
      background-size: cover;
      background-position: center;
      filter: blur(20px) brightness(0.4);
      z-index: 1;
      opacity: 1;
      transition: none;
    }

    .cube-face .book-view-cover-wrap {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 2;
      transform-style: flat;
    }

    .cube-face .book-view-cover {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: 100%;
      object-fit: contain;
      opacity: 1;
      transition: none;
    }

    .cube-face .book-view-text {
      position: absolute;
      padding: 2px 14px;
      background: #ffffff;
      color: #1a1a1a;
      z-index: 3;
      font-family: 'Courier Prime', 'Courier New', Courier, monospace;
      font-size: 16px;
      line-height: 1.4;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-width: calc(100% - 20px);
      /* Prevent 3D transform from affecting text rendering */
      transform: translateZ(0);
      transform-style: flat;
      -webkit-font-smoothing: antialiased;
    }

    .book-view-bg {
      position: absolute;
      top: -20px;
      left: -20px;
      right: -20px;
      bottom: -20px;
      background-size: cover;
      background-position: center;
      filter: blur(20px) brightness(0.4);
      z-index: 1;
      will-change: transform, opacity;
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .book-view-bg.loaded {
      opacity: 1;
    }

    .book-view-cover-wrap {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 2;
    }

    .book-view-cover {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: 100%;
      object-fit: contain;
      opacity: 0;
      transition: opacity 0.3s ease;
      will-change: opacity, transform;
    }

    .book-view-cover.loaded {
      opacity: 1;
    }

    .book-view-text {
      position: absolute;
      padding: 2px 14px;
      background: #ffffff;
      color: #1a1a1a;
      z-index: 3;
      font-family: 'Courier Prime', 'Courier New', Courier, monospace;
      font-size: 16px;
      line-height: 1.4;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-width: calc(100% - 20px);
    }

    /* Book View bottom info overlay */
    .book-view-info {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 24px 20px 32px;
      background: linear-gradient(transparent, rgba(0,0,0,0.8));
      z-index: 4;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .book-view-info.visible {
      opacity: 1;
    }

    .book-view-info-title {
      font-size: 18px;
      color: #fff;
      margin-bottom: 4px;
      letter-spacing: 0.5px;
    }

    .book-view-info-author {
      font-size: 13px;
      color: rgba(255,255,255,0.7);
      margin-bottom: 8px;
    }

    .book-view-info-date {
      font-size: 14px;
      color: #d4c4a8;
      letter-spacing: 1px;
      margin-top: 4px;
    }

    /* More button (shown on second tap) */
    .book-view-more-btn {
      position: absolute;
      top: calc(20px + env(safe-area-inset-top));
      right: 20px;
      background: #5c4d3d;
      border: none;
      width: 32px;
      height: 32px;
      cursor: pointer;
      border-radius: 50%;
      z-index: 6;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 3px;
      box-shadow: 0 2px 8px rgba(92, 77, 61, 0.3);
    }

    .book-view-more-btn .dot {
      width: 4px;
      height: 4px;
      background: #faf8f5;
      border-radius: 50%;
    }

    .book-view-more-btn.visible {
      opacity: 1;
      visibility: visible;
    }

    .book-view-more-btn:hover {
      background: #4a3e31;
    }

    /* Action menu */
    .action-menu {
      position: absolute;
      top: calc(64px + env(safe-area-inset-top));
      right: 20px;
      background: #faf8f5;
      border-radius: 4px;
      padding: 4px 0;
      min-width: 120px;
      z-index: 10;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, visibility 0.2s;
      box-shadow: 0 4px 16px rgba(0,0,0,0.25);
    }

    .action-menu.visible {
      opacity: 1;
      visibility: visible;
    }

    .action-menu-item {
      padding: 12px 20px;
      font-family: 'Courier Prime', 'Courier New', Courier, monospace;
      font-size: 14px;
      color: #5c4d3d;
      cursor: pointer;
      text-align: left;
      letter-spacing: 1px;
      text-transform: lowercase;
    }

    .action-menu-item:hover {
      background: #f0ebe4;
    }

    .action-menu-item.delete {
      color: #c9a088;
    }

    .action-menu-item + .action-menu-item {
      border-top: 1px solid #e8e4df;
    }


    /* Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(61, 52, 40, 0.6);
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: #faf8f5;
      padding: 28px;
      max-width: 320px;
      width: 90%;
      text-align: center;
      border-radius: 4px;
    }

    .modal h3 {
      font-size: 16px;
      font-weight: 400;
      letter-spacing: 2px;
      margin-bottom: 12px;
      text-transform: lowercase;
      color: #5c4d3d;
    }

    .modal p {
      color: #8b7355;
      margin-bottom: 24px;
      font-size: 14px;
      line-height: 1.5;
    }

    .modal-buttons {
      display: flex;
      gap: 12px;
    }

    .modal-btn {
      flex: 1;
      padding: 12px;
      font-family: inherit;
      font-size: 13px;
      cursor: pointer;
      letter-spacing: 1px;
      text-transform: lowercase;
    }

    .modal-btn.cancel {
      background: #fff;
      border: 1px solid #e8e4df;
      color: #5c4d3d;
    }

    .modal-btn.confirm {
      background: #c9a088;
      border: none;
      color: #fff;
    }

    .modal-btn.cancel:hover {
      background: #f5f0ea;
    }

    .modal-btn.confirm:hover {
      background: #b8847a;
    }

    /* Auth Screen */
    .auth-screen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 200;
      background: #faf8f5;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 40px 24px;
    }

    .auth-screen.hidden {
      display: none;
    }

    .auth-logo {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .auth-logo-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      width: 24px;
      height: 28px;
    }

    .auth-logo-icon::before,
    .auth-logo-icon::after {
      content: '';
      width: 2px;
      height: 22px;
      background: linear-gradient(to bottom, transparent, #8b7355 20%, #8b7355 80%, transparent);
      border-radius: 1px;
    }

    .auth-logo-icon::after {
      background: linear-gradient(to bottom, transparent, #a89078 20%, #a89078 80%, transparent);
    }

    .auth-title {
      font-size: 18px;
      font-weight: 400;
      letter-spacing: 4px;
      color: #5c4d3d;
      text-transform: lowercase;
    }

    .auth-subtitle {
      font-size: 11px;
      color: #b8a99a;
      letter-spacing: 0.5px;
      font-style: italic;
      margin-bottom: 48px;
    }

    .auth-btn-google {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      background: #fff;
      border: 1px solid #e8e4df;
      padding: 14px 32px;
      font-family: inherit;
      font-size: 14px;
      letter-spacing: 1px;
      color: #5c4d3d;
      cursor: pointer;
      text-transform: lowercase;
      margin-bottom: 16px;
      min-width: 260px;
      transition: background 0.2s;
    }

    .auth-btn-google:hover {
      background: #f5f0ea;
    }

    .auth-btn-google svg {
      width: 18px;
      height: 18px;
    }

    .auth-btn-skip {
      background: none;
      border: none;
      font-family: inherit;
      font-size: 12px;
      color: #b8a99a;
      cursor: pointer;
      letter-spacing: 1px;
      text-transform: lowercase;
      padding: 8px 16px;
    }

    .auth-btn-skip:hover {
      color: #8b7355;
    }

    /* Account Indicator */
    .account-indicator {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: #5c4d3d;
      color: #faf8f5;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
      overflow: hidden;
      flex-shrink: 0;
      position: relative;
    }

    .account-indicator.visible {
      display: flex;
    }

    .account-indicator img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* Account Dropdown */
    .account-dropdown {
      position: absolute;
      top: 48px;
      right: 20px;
      background: #faf8f5;
      border-radius: 4px;
      padding: 4px 0;
      min-width: 160px;
      z-index: 100;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, visibility 0.2s;
      box-shadow: 0 4px 16px rgba(0,0,0,0.15);
    }

    .account-dropdown.visible {
      opacity: 1;
      visibility: visible;
    }

    .account-dropdown-email {
      padding: 10px 16px;
      font-size: 11px;
      color: #a89078;
      border-bottom: 1px solid #e8e4df;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .account-dropdown-item {
      padding: 12px 16px;
      font-family: inherit;
      font-size: 13px;
      color: #5c4d3d;
      cursor: pointer;
      letter-spacing: 1px;
      text-transform: lowercase;
    }

    .account-dropdown-item:hover {
      background: #f0ebe4;
    }

    /* Sync Indicator */
    .sync-indicator {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(92, 77, 61, 0.85);
      color: #faf8f5;
      padding: 6px 14px;
      border-radius: 20px;
      font-family: inherit;
      font-size: 11px;
      letter-spacing: 0.5px;
      z-index: 150;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }

    .sync-indicator.visible {
      opacity: 1;
    }

  </style>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <!-- Auth Screen -->
  <div id="auth-screen" class="auth-screen hidden">
    <div class="auth-logo">
      <div class="auth-logo-icon"></div>
      <span class="auth-title">between pages</span>
    </div>
    <p class="auth-subtitle">thoughts left between the pages</p>
    <button class="auth-btn-google" onclick="signInWithGoogle()">
      <svg viewBox="0 0 24 24"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 0 1-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z" fill="#4285F4"/><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/><path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/></svg>
      sign in with google
    </button>
    <button class="auth-btn-skip" onclick="skipAuth()">continue without account</button>
  </div>

  <!-- Sync Indicator -->
  <div id="sync-indicator" class="sync-indicator"></div>

  <div class="container">
    <!-- Home View -->
    <div id="home-view" class="view active">
      <div class="sticky-header">
        <div class="logo-container" onclick="handleLogoClick(event)">
          <div class="logo-icon"></div>
          <h1><span>between</span><span>pages</span></h1>
        </div>
        <div class="header-divider"></div>
        <p class="tagline">thoughts left between the pages</p>
        <div id="account-indicator" class="account-indicator"></div>
        <div id="account-dropdown" class="account-dropdown">
          <div id="account-dropdown-email" class="account-dropdown-email"></div>
          <div class="account-dropdown-item" onclick="signOut()">sign out</div>
        </div>
      </div>
      <div id="timeline" class="timeline">
        <!-- Timeline content will be rendered here -->
      </div>
      <div id="year-indicator" class="year-indicator"></div>
      <button class="fab" onclick="showAddView()">+</button>
    </div>

    <!-- Add Book View -->
    <div id="add-view" class="view">
      <div class="header">
        <button class="back-btn" onclick="showHomeView()">&larr;</button>
        <span class="header-title">add book</span>
      </div>

      <div class="tabs">
        <button class="tab active" onclick="switchTab('search')">search</button>
        <button class="tab" onclick="switchTab('manual')">add by yourself</button>
      </div>

      <!-- Search Tab -->
      <div id="search-tab" class="tab-content active">
        <div class="search-row">
          <input type="text" id="search-input" class="search-input" placeholder="search by title or author..." onkeypress="handleSearchKeypress(event)">
          <button class="search-btn" onclick="searchBooks()">go</button>
        </div>
        <div id="search-results" class="search-results">
          <div class="search-message">search for a book above</div>
        </div>
      </div>

      <!-- Manual Tab -->
      <div id="manual-tab" class="tab-content">
        <div class="form">
          <input type="text" id="manual-title" class="form-input" placeholder="book title *">
          <input type="text" id="manual-author" class="form-input" placeholder="author">
          <input type="text" id="manual-year" class="form-input" placeholder="year read (e.g. 2024)">

          <div class="cover-section">
            <label class="cover-label">cover image</label>
            <div class="cover-options">
              <div class="cover-picker">
                <div id="cover-preview-container" class="cover-placeholder" onclick="document.getElementById('cover-input').click()">
                  <span class="cover-placeholder-icon">+</span>
                  <span class="cover-placeholder-text">upload</span>
                </div>
                <input type="file" id="cover-input" accept="image/*" onchange="handleImageUpload(event)">
              </div>
              <div class="cover-url-section">
                <span class="cover-or">or</span>
                <input type="text" id="cover-url-input" class="form-input cover-url-input" placeholder="paste image URL..." onchange="handleCoverUrlInput(event)">
              </div>
            </div>
          </div>

          <button class="save-btn" onclick="handleManualSubmit()">add book</button>
        </div>
      </div>
    </div>

    <!-- Book View (clean fullscreen display) -->
    <div id="book-view" class="view">
      <div class="book-view-container" id="book-view-container">
        <div class="book-view-bg" id="book-view-bg"></div>
        <div class="book-view-cover-wrap" id="book-view-cover-wrap">
          <img id="book-view-cover" class="book-view-cover" src="" alt="" decoding="async" crossorigin="anonymous">
        </div>

        <!-- More button (shown on second tap) -->
        <button id="book-view-more-btn" class="book-view-more-btn" onclick="toggleActionMenu(event)"><span class="dot"></span><span class="dot"></span><span class="dot"></span></button>

        <!-- Bottom info overlay (shown on second tap) -->
        <div id="book-view-info" class="book-view-info">
          <div id="book-view-info-title" class="book-view-info-title"></div>
          <div id="book-view-info-author" class="book-view-info-author"></div>
          <div id="book-view-info-date" class="book-view-info-date"></div>
        </div>

        <!-- Action menu (shown when ... is tapped) -->
        <div id="action-menu" class="action-menu">
          <div class="action-menu-item" onclick="openEditView()">edit</div>
          <div class="action-menu-item delete" onclick="showDeleteModal()">delete</div>
        </div>
      </div>
    </div>

    <!-- Edit View -->
    <div id="edit-view" class="view">
      <div class="edit-view-container" id="edit-view-container">
        <div class="edit-cover-bg" id="edit-cover-bg"></div>

        <!-- Stories-style toolbar (top center) -->
        <div id="stories-toolbar" class="stories-toolbar">
          <button class="toolbar-btn" id="font-style-btn" title="Change font">
            <span class="font-preview">Aa</span>
          </button>
          <button class="toolbar-btn" id="text-color-btn" title="Text color">
            <span class="color-indicator" id="text-color-indicator"></span>
          </button>
          <button class="toolbar-btn" id="bg-color-btn" title="Background color">
            <span class="highlight-icon">A</span>
          </button>
          <button class="toolbar-btn" id="eyedropper-btn" title="Pick color from cover">
            <span class="eyedropper-icon">&#9673;</span>
          </button>
          <button class="toolbar-btn done-btn" id="done-btn">Done</button>
        </div>
        <!-- Hidden legacy toolbar for compatibility -->
        <div id="color-toolbar" class="color-toolbar" style="display:none;"></div>

        <!-- Font picker dropdown -->
        <div id="font-picker" class="font-picker">
          <div class="font-option" data-index="0" onclick="selectFontStyle(0)">
            <span class="font-option-preview" style="font-family: 'Courier Prime', monospace;">Aa</span>
            <span class="font-option-name">Classic</span>
          </div>
          <div class="font-option" data-index="1" onclick="selectFontStyle(1)">
            <span class="font-option-preview" style="font-family: 'Helvetica Neue', Arial, sans-serif;">Aa</span>
            <span class="font-option-name">Modern</span>
          </div>
          <div class="font-option" data-index="2" onclick="selectFontStyle(2)">
            <span class="font-option-preview" style="font-family: 'Georgia', serif;">Aa</span>
            <span class="font-option-name">Elegant</span>
          </div>
        </div>

        <!-- Color palette dropdown -->
        <div id="color-picker" class="color-picker">
          <div class="color-picker-section">
            <div class="color-picker-label">standard</div>
            <div id="palette-colors" class="color-swatches"></div>
          </div>
          <div id="extracted-colors-section" class="color-picker-section" style="display: none;">
            <div class="color-picker-label">from cover</div>
            <div id="extracted-colors" class="color-swatches"></div>
          </div>
        </div>

        <!-- Eyedropper overlay -->
        <div id="eyedropper-overlay" class="eyedropper-overlay"></div>
        <div id="eyedropper-preview" class="eyedropper-preview"></div>

        <div class="edit-cover-wrap" id="edit-cover-wrap">
          <img id="edit-cover" class="edit-cover" src="" alt="" crossorigin="anonymous">

          <!-- Editable text box -->
          <div id="edit-text-box" class="edit-text-box" style="display: none;">
            <textarea id="edit-text-box-input" class="edit-text-box-input" rows="1" placeholder="" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"></textarea>
            <div id="edit-text-box-display" class="edit-text-box-display" style="display: none;"></div>
          </div>

        </div>

        <!-- Trash icon for deleting text box -->
        <div id="edit-trash" class="edit-trash"></div>

        <!-- Save button -->
        <button class="edit-save-btn" id="edit-save-btn">save</button>
      </div>
    </div>
  </div>

  <!-- Delete Confirmation Modal -->
  <div id="delete-modal" class="modal-overlay">
    <div class="modal">
      <h3>delete book</h3>
      <p>remove this book from your journal?</p>
      <div class="modal-buttons">
        <button class="modal-btn cancel" onclick="hideDeleteModal()">cancel</button>
        <button class="modal-btn confirm" onclick="confirmDelete()">delete</button>
      </div>
    </div>
  </div>

  <script>
    // Storage key
    const BOOKS_KEY = 'between_pages_books_v5';

    // ==========================================
    // Supabase Configuration
    // ==========================================
    const SUPABASE_URL = 'https://rqarzveebwgvuqdocifh.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJxYXJ6dmVlYndndnVxZG9jaWZoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA1NDI3OTksImV4cCI6MjA4NjExODc5OX0.3U9aI0CN-45rHAMH0hk7LUO24QMs5wV93gBLPML8ELs';

    let supabaseClient = null;
    let currentUser = null;
    let isOnline = navigator.onLine;
    let isSyncing = false;
    let realtimeChannel = null;
    let lastSyncedBookId = null; // Guard against echoing own realtime writes

    // Initialize Supabase client (only if configured)
    function getSupabase() {
      if (supabaseClient) return supabaseClient;
      if (SUPABASE_URL === 'YOUR_SUPABASE_URL' || SUPABASE_ANON_KEY === 'YOUR_SUPABASE_ANON_KEY') {
        return null;
      }
      try {
        supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        return supabaseClient;
      } catch (e) {
        console.error('[Sync] Failed to init Supabase:', e);
        return null;
      }
    }

    // ==========================================
    // Auth Functions
    // ==========================================
    async function initAuth() {
      const sb = getSupabase();
      if (!sb) {
        // Supabase not configured — skip auth entirely
        document.getElementById('auth-screen').classList.add('hidden');
        return;
      }

      // Check if user previously skipped auth
      const skipped = localStorage.getItem('bp_auth_skipped');

      // Check existing session
      const { data: { session } } = await sb.auth.getSession();
      if (session) {
        currentUser = session.user;
        onAuthSuccess();
        return;
      }

      // If user previously skipped, don't show auth screen
      if (skipped) {
        document.getElementById('auth-screen').classList.add('hidden');
      } else {
        document.getElementById('auth-screen').classList.remove('hidden');
      }

      // Listen for auth state changes (handles OAuth redirect)
      sb.auth.onAuthStateChange((event, session) => {
        if (event === 'SIGNED_IN' && session) {
          currentUser = session.user;
          onAuthSuccess();
        } else if (event === 'SIGNED_OUT') {
          currentUser = null;
          hideAccountIndicator();
          if (realtimeChannel) {
            const sb2 = getSupabase();
            if (sb2) sb2.removeChannel(realtimeChannel);
            realtimeChannel = null;
          }
        }
      });
    }

    async function signInWithGoogle() {
      const sb = getSupabase();
      if (!sb) return;
      const { error } = await sb.auth.signInWithOAuth({
        provider: 'google',
        options: {
          redirectTo: window.location.origin + window.location.pathname
        }
      });
      if (error) {
        console.error('[Auth] Google sign-in error:', error);
        alert('Sign-in failed. Please try again.');
      }
    }

    function skipAuth() {
      localStorage.setItem('bp_auth_skipped', 'true');
      document.getElementById('auth-screen').classList.add('hidden');
    }

    async function signOut() {
      const sb = getSupabase();
      if (!sb) return;
      hideAccountDropdown();
      await sb.auth.signOut();
      currentUser = null;
      hideAccountIndicator();
      localStorage.removeItem('bp_auth_skipped');
      document.getElementById('auth-screen').classList.remove('hidden');
    }

    function onAuthSuccess() {
      document.getElementById('auth-screen').classList.add('hidden');
      localStorage.removeItem('bp_auth_skipped');
      showAccountIndicator();
      // Migrate existing local books, then sync, then subscribe to realtime
      migrateLocalBooksToSupabase().then(() => {
        syncFromSupabase().then(() => {
          subscribeToRealtime();
          processOfflineQueue();
        });
      });
    }

    // Account indicator helpers
    function showAccountIndicator() {
      const emailEl = document.getElementById('account-dropdown-email');
      if (!currentUser) return;

      emailEl.textContent = currentUser.email || '';
      document.querySelector('.logo-container').style.cursor = 'pointer';
    }

    function hideAccountIndicator() {
      document.querySelector('.logo-container').style.cursor = '';
      hideAccountDropdown();
    }

    function handleLogoClick(e) {
      if (!currentUser) return;
      toggleAccountDropdown(e);
    }

    function toggleAccountDropdown(e) {
      e.stopPropagation();
      const dd = document.getElementById('account-dropdown');
      dd.classList.toggle('visible');

      // Close on outside click
      if (dd.classList.contains('visible')) {
        setTimeout(() => {
          document.addEventListener('click', closeAccountDropdownOutside, { once: true });
        }, 0);
      }
    }

    function closeAccountDropdownOutside() {
      hideAccountDropdown();
    }

    function hideAccountDropdown() {
      document.getElementById('account-dropdown').classList.remove('visible');
    }

    // ==========================================
    // Sync Engine
    // ==========================================
    function generateBookId() {
      if (typeof crypto !== 'undefined' && crypto.randomUUID) {
        return 'book_' + crypto.randomUUID();
      }
      return 'book_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    // Convert JS camelCase book to DB snake_case row
    function bookToRow(book, userId) {
      return {
        id: book.id,
        user_id: userId,
        title: book.title,
        author: book.author || 'Unknown Author',
        cover_url: book.coverUrl || '',
        year_read: book.yearRead || '',
        date_added: book.dateAdded || new Date().toISOString(),
        summary: book.summary || '',
        reflection: book.reflection || '',
        text_boxes: book.textBoxes || [],
        text_box_color: book.textBoxColor || '#ffffff',
        text_box_x: book.textBoxX || 0,
        text_box_y: book.textBoxY || 0,
        updated_at: new Date().toISOString()
      };
    }

    // Convert DB snake_case row to JS camelCase book
    function rowToBook(row) {
      return {
        id: row.id,
        title: row.title,
        author: row.author || 'Unknown Author',
        coverUrl: row.cover_url || '',
        yearRead: row.year_read || '',
        dateAdded: row.date_added || '',
        summary: row.summary || '',
        reflection: row.reflection || '',
        textBoxes: row.text_boxes || [],
        textBoxColor: row.text_box_color || '#ffffff',
        textBoxX: row.text_box_x || 0,
        textBoxY: row.text_box_y || 0,
        updatedAt: row.updated_at || ''
      };
    }

    // Push a single book operation to Supabase
    async function syncBookToSupabase(book, operation) {
      if (!currentUser) return;
      const sb = getSupabase();
      if (!sb) return;

      try {
        if (operation === 'DELETE') {
          const { error } = await sb.from('books').delete().eq('id', book.id).eq('user_id', currentUser.id);
          if (error) throw error;
        } else {
          // Upload base64 cover first if needed
          const processedBook = await uploadCoverIfBase64(book);
          const row = bookToRow(processedBook, currentUser.id);
          lastSyncedBookId = row.id;
          const { error } = await sb.from('books').upsert(row, { onConflict: 'id' });
          if (error) throw error;

          // If cover URL changed after upload, update localStorage too
          if (processedBook.coverUrl !== book.coverUrl) {
            const books = getBooks();
            const idx = books.findIndex(b => b.id === book.id);
            if (idx !== -1) {
              books[idx].coverUrl = processedBook.coverUrl;
              saveBooks(books);
            }
          }
        }
      } catch (e) {
        console.warn('[Sync] Push failed, queuing:', e.message);
        queueSyncOperation(book, operation);
      }
    }

    // Pull all user's books from Supabase and merge with local
    async function syncFromSupabase() {
      if (!currentUser) return;
      const sb = getSupabase();
      if (!sb) return;
      if (isSyncing) return;

      isSyncing = true;
      showSyncIndicator('syncing...');

      try {
        const { data, error } = await sb.from('books').select('*').eq('user_id', currentUser.id);
        if (error) throw error;

        const remoteBooks = (data || []).map(rowToBook);
        const localBooks = getBooks();
        const merged = mergeBooks(localBooks, remoteBooks);
        saveBooks(merged);
        renderTimeline();
        showSyncIndicator('synced');
      } catch (e) {
        console.error('[Sync] Pull failed:', e);
        showSyncIndicator('sync error');
      } finally {
        isSyncing = false;
        setTimeout(hideSyncIndicator, 2000);
      }
    }

    // Merge local and remote books — remote wins for conflicts, keeps local-only books
    function mergeBooks(localBooks, remoteBooks) {
      const remoteMap = new Map();
      remoteBooks.forEach(b => remoteMap.set(b.id, b));

      const merged = [];
      const seen = new Set();

      // Add all remote books (they win conflicts)
      remoteBooks.forEach(b => {
        merged.push(b);
        seen.add(b.id);
      });

      // Add local-only books (not in remote, not sample books)
      localBooks.forEach(b => {
        if (!seen.has(b.id) && !b.id.startsWith('sample_')) {
          merged.push(b);
        }
      });

      // Keep sample books from local
      localBooks.forEach(b => {
        if (b.id.startsWith('sample_') && !seen.has(b.id)) {
          merged.push(b);
        }
      });

      return merged;
    }

    // ==========================================
    // Cover Upload (Base64 -> Supabase Storage)
    // ==========================================
    function isBase64Cover(url) {
      return url && url.startsWith('data:');
    }

    async function uploadCoverIfBase64(book) {
      if (!isBase64Cover(book.coverUrl)) return book;
      if (!currentUser) return book;
      const sb = getSupabase();
      if (!sb) return book;

      try {
        // Convert base64 to blob
        const response = await fetch(book.coverUrl);
        const blob = await response.blob();

        const filePath = `${currentUser.id}/${book.id}.jpg`;
        const { error: uploadError } = await sb.storage
          .from('covers')
          .upload(filePath, blob, { upsert: true, contentType: 'image/jpeg' });

        if (uploadError) throw uploadError;

        // Get public URL
        const { data: { publicUrl } } = sb.storage.from('covers').getPublicUrl(filePath);

        return { ...book, coverUrl: publicUrl };
      } catch (e) {
        console.warn('[Sync] Cover upload failed:', e.message);
        return book; // Keep base64 URL as fallback
      }
    }

    // ==========================================
    // Offline Queue
    // ==========================================
    const OFFLINE_QUEUE_KEY = 'bp_offline_queue';

    function queueSyncOperation(book, operation) {
      const queue = JSON.parse(localStorage.getItem(OFFLINE_QUEUE_KEY) || '[]');
      // Replace existing entry for the same book id
      const existingIdx = queue.findIndex(q => q.book.id === book.id);
      if (existingIdx !== -1) {
        // If new op is DELETE, replace. Otherwise update the book data.
        if (operation === 'DELETE') {
          queue[existingIdx] = { book: { id: book.id }, operation: 'DELETE' };
        } else {
          queue[existingIdx] = { book, operation };
        }
      } else {
        queue.push({ book, operation });
      }
      localStorage.setItem(OFFLINE_QUEUE_KEY, JSON.stringify(queue));
    }

    async function processOfflineQueue() {
      if (!currentUser) return;
      const sb = getSupabase();
      if (!sb) return;
      if (!isOnline) return;

      const queue = JSON.parse(localStorage.getItem(OFFLINE_QUEUE_KEY) || '[]');
      if (queue.length === 0) return;

      showSyncIndicator('syncing...');
      const remaining = [];

      for (const item of queue) {
        try {
          if (item.operation === 'DELETE') {
            const { error } = await sb.from('books').delete().eq('id', item.book.id).eq('user_id', currentUser.id);
            if (error) throw error;
          } else {
            const processedBook = await uploadCoverIfBase64(item.book);
            const row = bookToRow(processedBook, currentUser.id);
            const { error } = await sb.from('books').upsert(row, { onConflict: 'id' });
            if (error) throw error;
          }
        } catch (e) {
          console.warn('[Sync] Queue item failed:', e.message);
          remaining.push(item);
        }
      }

      localStorage.setItem(OFFLINE_QUEUE_KEY, JSON.stringify(remaining));
      if (remaining.length === 0) {
        showSyncIndicator('synced');
      } else {
        showSyncIndicator('some items pending');
      }
      setTimeout(hideSyncIndicator, 2000);
    }

    // Online/offline listeners
    window.addEventListener('online', () => {
      isOnline = true;
      processOfflineQueue();
    });
    window.addEventListener('offline', () => {
      isOnline = false;
    });

    // ==========================================
    // Realtime Subscriptions
    // ==========================================
    function subscribeToRealtime() {
      if (!currentUser) return;
      const sb = getSupabase();
      if (!sb) return;

      // Remove existing channel
      if (realtimeChannel) {
        sb.removeChannel(realtimeChannel);
      }

      realtimeChannel = sb
        .channel('books-changes')
        .on('postgres_changes', {
          event: '*',
          schema: 'public',
          table: 'books',
          filter: `user_id=eq.${currentUser.id}`
        }, (payload) => {
          handleRealtimeChange(payload);
        })
        .subscribe();
    }

    function handleRealtimeChange(payload) {
      const { eventType, new: newRow, old: oldRow } = payload;

      // Guard against echoing own writes
      if (newRow && newRow.id === lastSyncedBookId) {
        lastSyncedBookId = null;
        return;
      }

      const books = getBooks();

      if (eventType === 'INSERT' || eventType === 'UPDATE') {
        const remoteBook = rowToBook(newRow);
        const idx = books.findIndex(b => b.id === remoteBook.id);
        if (idx !== -1) {
          books[idx] = remoteBook;
        } else {
          books.unshift(remoteBook);
        }
        saveBooks(books);
        renderTimeline();

        // If viewing this book, re-render
        if (selectedBook && selectedBook.id === remoteBook.id) {
          selectedBook = remoteBook;
          if (currentView === 'book') renderBookView(false);
        }
      } else if (eventType === 'DELETE') {
        const deletedId = oldRow?.id;
        if (deletedId) {
          saveBooks(books.filter(b => b.id !== deletedId));
          renderTimeline();

          // If viewing this book, go home
          if (selectedBook && selectedBook.id === deletedId) {
            showHomeView();
          }
        }
      }
    }

    // ==========================================
    // Migration: Local -> Supabase on first sign-in
    // ==========================================
    async function migrateLocalBooksToSupabase() {
      if (!currentUser) return;
      const sb = getSupabase();
      if (!sb) return;

      const migrationKey = `bp_migrated_${currentUser.id}`;
      if (localStorage.getItem(migrationKey)) return; // Already migrated

      const books = getBooks();
      const userBooks = books.filter(b => !b.id.startsWith('sample_'));
      if (userBooks.length === 0) {
        localStorage.setItem(migrationKey, 'true');
        return;
      }

      showSyncIndicator('migrating books...');

      for (const book of userBooks) {
        try {
          const processedBook = await uploadCoverIfBase64(book);
          const row = bookToRow(processedBook, currentUser.id);
          await sb.from('books').upsert(row, { onConflict: 'id' });

          // Update coverUrl in localStorage if it changed
          if (processedBook.coverUrl !== book.coverUrl) {
            const allBooks = getBooks();
            const idx = allBooks.findIndex(b => b.id === book.id);
            if (idx !== -1) {
              allBooks[idx].coverUrl = processedBook.coverUrl;
              saveBooks(allBooks);
            }
          }
        } catch (e) {
          console.warn('[Migration] Failed to migrate book:', book.title, e.message);
          queueSyncOperation(book, 'UPSERT');
        }
      }

      localStorage.setItem(migrationKey, 'true');
      showSyncIndicator('migration complete');
      setTimeout(hideSyncIndicator, 2000);
    }

    // ==========================================
    // Sync Indicator UI
    // ==========================================
    function showSyncIndicator(text) {
      const el = document.getElementById('sync-indicator');
      el.textContent = text;
      el.classList.add('visible');
    }

    function hideSyncIndicator() {
      document.getElementById('sync-indicator').classList.remove('visible');
    }

    // Sample books for demo
    const SAMPLE_BOOKS = [
      {
        id: 'sample_1',
        title: 'The Great Gatsby',
        author: 'F. Scott Fitzgerald',
        coverUrl: 'https://covers.openlibrary.org/b/isbn/9780743273565-L.jpg',
        reflection: 'A haunting portrayal of the American Dream',
        textBoxColor: '#ffffff',
        textBoxX: 20,
        textBoxY: 350,
        dateAdded: '2024-03-15',
        yearRead: '2024',
        summary: 'A story of the mysteriously wealthy Jay Gatsby and his love for Daisy Buchanan, set against the backdrop of 1920s Long Island.',
      },
      {
        id: 'sample_2',
        title: 'The Little Prince',
        author: 'Antoine de Saint-Exupéry',
        coverUrl: 'https://covers.openlibrary.org/b/isbn/9780156012195-L.jpg',
        reflection: 'All grown-ups were once children... but only few remember it.',
        textBoxColor: '#1a1a1a',
        textBoxX: 20,
        textBoxY: 280,
        dateAdded: '2024-06-20',
        yearRead: '2024',
        summary: 'A poetic tale of a young prince who travels from planet to planet.',
      },
      {
        id: 'sample_3',
        title: 'Norwegian Wood',
        author: 'Haruki Murakami',
        coverUrl: 'https://covers.openlibrary.org/b/isbn/9780375704024-L.jpg',
        reflection: 'Deep thoughts on youth, love and loss',
        textBoxColor: '#3c3c3c',
        textBoxX: 20,
        textBoxY: 320,
        dateAdded: '2023-05-22',
        yearRead: '2023',
        summary: 'Set in Tokyo during the late 1960s, this nostalgic story follows Toru Watanabe.',
      },
      {
        id: 'sample_4',
        title: '1984',
        author: 'George Orwell',
        coverUrl: 'https://covers.openlibrary.org/b/isbn/9780451524935-L.jpg',
        reflection: 'Big Brother is watching',
        textBoxColor: '#ffffff',
        textBoxX: 20,
        textBoxY: 300,
        dateAdded: '2023-02-10',
        yearRead: '2023',
        summary: 'A dystopian novel about totalitarianism and surveillance.',
      },
      {
        id: 'sample_5',
        title: 'Pride and Prejudice',
        author: 'Jane Austen',
        coverUrl: 'https://covers.openlibrary.org/b/isbn/9780141439518-L.jpg',
        reflection: 'A truth universally acknowledged',
        textBoxColor: '#f5ebe0',
        textBoxX: 20,
        textBoxY: 280,
        dateAdded: '2022-11-15',
        yearRead: '2022',
        summary: 'A romantic novel about Elizabeth Bennet and Mr. Darcy.',
      },
      {
        id: 'sample_6',
        title: 'The Catcher in the Rye',
        author: 'J.D. Salinger',
        coverUrl: 'https://covers.openlibrary.org/b/isbn/9780316769488-L.jpg',
        reflection: 'Holden Caulfield speaks to the lost teenager in all of us',
        textBoxColor: '#1a1a1a',
        textBoxX: 20,
        textBoxY: 320,
        dateAdded: '2022-06-20',
        yearRead: '2022',
        summary: 'A story of teenage alienation and angst.',
      },
      {
        id: 'sample_7',
        title: 'To Kill a Mockingbird',
        author: 'Harper Lee',
        coverUrl: 'https://covers.openlibrary.org/b/isbn/9780061120084-L.jpg',
        reflection: 'You never really understand a person until you climb into their skin',
        textBoxColor: '#ffffff',
        textBoxX: 20,
        textBoxY: 300,
        dateAdded: '2021-08-05',
        yearRead: '2021',
        summary: 'A novel about racial injustice in the American South.',
      },
      {
        id: 'sample_8',
        title: 'The Alchemist',
        author: 'Paulo Coelho',
        coverUrl: 'https://covers.openlibrary.org/b/isbn/9780062315007-L.jpg',
        reflection: 'When you want something, all the universe conspires to help you',
        textBoxColor: '#f5ebe0',
        textBoxX: 20,
        textBoxY: 280,
        dateAdded: '2021-03-12',
        yearRead: '2021',
        summary: 'A fable about following your dreams.',
      },
      {
        id: 'sample_9',
        title: 'Sapiens',
        author: 'Yuval Noah Harari',
        coverUrl: 'https://covers.openlibrary.org/b/isbn/9780062316097-L.jpg',
        reflection: 'A brief history of humankind that changed my perspective',
        textBoxColor: '#ffffff',
        textBoxX: 20,
        textBoxY: 300,
        dateAdded: '2020-12-01',
        yearRead: '2020',
        summary: 'A narrative history of humanity from the Stone Age to the present.',
      },
    ];

    // App state
    let currentView = 'home';
    let selectedBook = null;
    let uploadedCoverBase64 = null;

    // Book View state
    let bookViewTapCount = 0;
    let bookViewTapTimer = null;
    let bookViewSwipeStartY = 0;
    let bookViewSwipeStartX = 0;
    let actionMenuVisible = false;
    let overlayVisible = false;

    // Edit View state
    let lastToolbarTouch = 0; // Timestamp to deduplicate touch + click on iOS
    let editTextBoxes = []; // Array of {id, text, x, y, color, textColor, fontStyle, fontSize}
    let currentTextBoxId = null;
    let textBoxX = 0;
    let textBoxY = 0;
    let isEditing = false;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let textBoxStartX = 0;
    let textBoxStartY = 0;
    let dragStartDistance = 0; // For distinguishing tap from drag
    let longPressTimer = null; // For active text box dragging
    let coverWrapRect = null;

    // Font style constants
    const FONT_STYLES = [
      { name: 'Classic', family: "'Courier Prime', monospace" },
      { name: 'Modern', family: "'Helvetica Neue', Arial, sans-serif" },
      { name: 'Elegant', family: "'Georgia', serif" }
    ];
    const DEFAULT_FONT_SIZE = 16;
    const MIN_FONT_SIZE = 12;
    const MAX_FONT_SIZE = 48;

    // Pinch-to-resize state
    let isPinching = false;
    let pinchStartDistance = 0;
    let pinchStartFontSize = DEFAULT_FONT_SIZE;
    let currentFontStyleIndex = 0;
    let currentFontSize = DEFAULT_FONT_SIZE;

    // Color picker state
    let colorPickerMode = null; // 'bg' or 'text'
    let extractedColors = [];
    // lockedViewportHeight removed — was used to lock container height during iOS
    // keyboard open, but position:fixed + top:0/bottom:0 handles this correctly.
    let eyedropperActive = false;
    let eyedropperMode = 'text'; // 'bg' or 'text' - default to text
    let eyedropperCanvas = null;
    let eyedropperCtx = null;
    let eyedropperPickedColor = null;
    const appPalette = [
      '#ffffff', '#000000', '#ff3b30', '#ff9500',
      '#ffcc00', '#34c759', '#00c7be', '#30b0c7',
      '#007aff', '#5856d6', '#af52de', '#ff2d55',
      '#a2845e', '#8e8e93', '#f5ebe0', '#5c4d3d'
    ];

    // Initialize app
    document.addEventListener('DOMContentLoaded', () => {
      initializeBooks();
      renderTimeline();
      setupHistoryNavigation();
      setupBookView();
      setupEditView();
      setupYearIndicator();
    });

    // Initialize books with samples if empty
    async function initializeBooks() {
      const data = localStorage.getItem(BOOKS_KEY);
      if (!data) {
        localStorage.setItem(BOOKS_KEY, JSON.stringify(SAMPLE_BOOKS));
      }
      renderTimeline();
      // Initialize auth (non-blocking — app renders immediately from localStorage)
      initAuth();
    }

    // History navigation
    function setupHistoryNavigation() {
      window.addEventListener('popstate', (event) => {
        if (event.state && event.state.view) {
          if (event.state.view === 'home') {
            showHomeView(false);
          } else if (event.state.view === 'add') {
            showAddView(false);
          } else if (event.state.view === 'book' && event.state.bookId) {
            const book = getBooks().find(b => b.id === event.state.bookId);
            if (book) showBookView(book, false);
            else showHomeView(false);
          } else if (event.state.view === 'edit' && event.state.bookId) {
            const book = getBooks().find(b => b.id === event.state.bookId);
            if (book) showEditView(book, false);
            else showHomeView(false);
          }
        } else {
          showHomeView(false);
        }
      });
      history.replaceState({ view: 'home' }, '', '');
    }

    // Storage functions
    function getBooks() {
      const data = localStorage.getItem(BOOKS_KEY);
      return data ? JSON.parse(data) : SAMPLE_BOOKS;
    }

    function saveBooks(books) {
      localStorage.setItem(BOOKS_KEY, JSON.stringify(books));
    }

    function addBook(book) {
      const books = getBooks();
      book.id = generateBookId();
      book.dateAdded = new Date().toISOString();
      book.textBoxes = []; // Array of {text, x, y, color}
      book.yearRead = book.yearRead || new Date().getFullYear().toString();
      book.summary = book.summary || '';
      books.unshift(book);
      saveBooks(books);
      // Async sync to Supabase
      syncBookToSupabase(book, 'INSERT');
      return book;
    }

    function updateBook(bookId, updates) {
      const books = getBooks();
      const index = books.findIndex(b => b.id === bookId);
      if (index !== -1) {
        books[index] = { ...books[index], ...updates };
        saveBooks(books);
        // Async sync to Supabase (skip sample books)
        if (!bookId.startsWith('sample_')) {
          syncBookToSupabase(books[index], 'UPDATE');
        }
        return books[index];
      }
      return null;
    }

    function deleteBook(bookId) {
      const books = getBooks();
      saveBooks(books.filter(b => b.id !== bookId));
      // Async sync to Supabase (skip sample books)
      if (!bookId.startsWith('sample_')) {
        syncBookToSupabase({ id: bookId }, 'DELETE');
      }
    }

    // View navigation
    function showHomeView(pushState = true, animate = true) {
      const bookViewContainer = document.getElementById('book-view-container');

      // If coming from Book View, animate out
      if (animate && currentView === 'book') {
        bookViewContainer.classList.add('closing');
        setTimeout(() => {
          bookViewContainer.classList.remove('closing');
          completeShowHomeView(pushState);
        }, 480);
      } else {
        completeShowHomeView(pushState);
      }
    }

    function resetEditViewLayout() {
      const container = document.getElementById('edit-view-container');
      container.style.height = '';
      container.style.top = '';
    }

    function completeShowHomeView(pushState) {
      document.getElementById('home-view').classList.add('active');
      document.getElementById('add-view').classList.remove('active');
      document.getElementById('book-view').classList.remove('active');
      document.getElementById('edit-view').classList.remove('active');
      resetEditViewLayout();
      currentView = 'home';
      selectedBook = null;
      renderTimeline();
      if (pushState) history.pushState({ view: 'home' }, '', '');
    }

    function showAddView(pushState = true) {
      document.getElementById('home-view').classList.remove('active');
      document.getElementById('add-view').classList.add('active');
      document.getElementById('book-view').classList.remove('active');
      document.getElementById('edit-view').classList.remove('active');
      resetEditViewLayout();
      currentView = 'add';
      resetAddForm();
      if (pushState) history.pushState({ view: 'add' }, '', '');
    }

    function showBookView(book, pushState = true, animate = true) {
      document.getElementById('home-view').classList.remove('active');
      document.getElementById('add-view').classList.remove('active');
      document.getElementById('book-view').classList.add('active');
      document.getElementById('edit-view').classList.remove('active');
      resetEditViewLayout();
      currentView = 'book';
      selectedBook = book;
      renderBookView(animate);
      if (pushState) history.pushState({ view: 'book', bookId: book.id }, '', '');
    }

    function showEditView(book, pushState = true) {
      document.getElementById('home-view').classList.remove('active');
      document.getElementById('add-view').classList.remove('active');
      document.getElementById('book-view').classList.remove('active');
      document.getElementById('edit-view').classList.add('active');
      currentView = 'edit';
      selectedBook = book;

      // Reset any inline styles from previous edit session
      const container = document.getElementById('edit-view-container');
      container.style.height = '';
      container.style.top = '';

      renderEditView();
      if (pushState) history.pushState({ view: 'edit', bookId: book.id }, '', '');
    }

    function openEditView() {
      hideActionMenu();
      if (selectedBook) {
        showEditView(selectedBook);
      }
    }

    // Book View setup and rendering
    function setupBookView() {
      const container = document.getElementById('book-view-container');

      // Touch events for tap and swipe
      container.addEventListener('touchstart', handleBookViewTouchStart, { passive: false });
      container.addEventListener('touchmove', handleBookViewTouchMove, { passive: false });
      container.addEventListener('touchend', handleBookViewTouchEnd);

      // Mouse click for desktop
      container.addEventListener('click', handleBookViewClick);
    }

    function renderBookView(animate = true, skipFade = false) {
      const book = selectedBook;
      const container = document.getElementById('book-view-container');

      // Reset state
      bookViewTapCount = 0;
      overlayVisible = false;
      actionMenuVisible = false;
      container.classList.remove('closing');

      // Control animation
      if (animate) {
        container.style.animation = 'bookViewIn 0.35s ease forwards';
      } else {
        container.style.animation = 'none';
      }

      document.getElementById('book-view-info').classList.remove('visible');
      document.getElementById('book-view-more-btn').classList.remove('visible');
      document.getElementById('action-menu').classList.remove('visible');

      // Set cover image with fade-in on load
      const coverUrl = book.coverUrl || 'https://via.placeholder.com/300x450/f0f0f0/999?text=No+Cover';
      const bookViewCover = document.getElementById('book-view-cover');
      const bookViewBg = document.getElementById('book-view-bg');

      if (skipFade) {
        // Cube transition: image already decoded, show instantly.
        // decoding='sync' ensures the browser paints the pre-decoded
        // bitmap in this frame rather than deferring it (as 'async' would).
        bookViewCover.onload = null;
        bookViewCover.decoding = 'sync';
        bookViewCover.style.transition = 'none';
        bookViewBg.style.transition = 'none';
        bookViewCover.src = coverUrl;
        bookViewCover.classList.add('loaded');
        bookViewBg.classList.add('loaded');
      } else {
        // Normal: fade in cover when loaded
        // Clear any inline overrides left by a prior skipFade
        bookViewCover.decoding = 'async';
        bookViewCover.style.transition = '';
        bookViewBg.style.transition = '';
        bookViewCover.classList.remove('loaded');
        bookViewBg.classList.remove('loaded');

        bookViewCover.onload = () => {
          bookViewCover.classList.add('loaded');
          bookViewBg.classList.add('loaded');
        };

        if (bookViewCover.src !== coverUrl) {
          bookViewCover.src = coverUrl;
        } else if (bookViewCover.complete) {
          // Same image, already loaded — show immediately
          bookViewCover.classList.add('loaded');
          bookViewBg.classList.add('loaded');
        }
      }
      bookViewBg.style.backgroundImage = `url(${coverUrl})`;

      // Clear existing text boxes
      const textContainer = document.getElementById('book-view-cover-wrap');
      textContainer.querySelectorAll('.book-view-text').forEach(el => el.remove());

      // Get text boxes (support both old and new format)
      const textBoxes = book.textBoxes || (book.reflection ? [{
        text: book.reflection,
        x: book.textBoxX || 20,
        y: book.textBoxY || 300,
        color: book.textBoxColor || '#ffffff'
      }] : []);

      // Render all text boxes
      textBoxes.forEach(tb => {
        if (!tb.text) return;
        const textEl = document.createElement('div');
        textEl.className = 'book-view-text';
        const bgColor = tb.color || '#ffffff';
        const hasBg = bgColor && bgColor !== 'transparent' && bgColor !== 'rgba(0, 0, 0, 0)';
        const textColor = tb.textColor || (hasBg && isLightColorSimple(bgColor) ? '#1a1a1a' : '#ffffff');

        // Apply font style and size with backward compatibility
        const fontStyleIndex = tb.fontStyle !== undefined ? tb.fontStyle : 0;
        const fontSize = tb.fontSize || 16;
        const fontFamily = fontStyleIndex < FONT_STYLES.length ? FONT_STYLES[fontStyleIndex].family : FONT_STYLES[0].family;

        textEl.style.display = 'block';
        textEl.textContent = tb.text;
        textEl.style.left = tb.x + 'px';
        textEl.style.top = tb.y + 'px';
        textEl.style.backgroundColor = hasBg ? bgColor : 'transparent';
        textEl.style.color = textColor;
        textEl.style.fontFamily = fontFamily;
        textEl.style.fontSize = fontSize + 'px';
        textContainer.appendChild(textEl);
      });

      function isLightColorSimple(hex) {
        if (!hex || hex.length < 7) return true;
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return (r * 299 + g * 587 + b * 114) / 1000 > 180;
      }

      // Set info overlay
      const yearRead = book.yearRead || new Date(book.dateAdded).getFullYear().toString();
      document.getElementById('book-view-info-title').textContent = book.title;
      document.getElementById('book-view-info-author').textContent = book.author || 'Unknown Author';
      document.getElementById('book-view-info-date').textContent = `read in ${yearRead}`;

      // Preload adjacent book covers
      preloadAdjacentBooks();
    }

    // Persistent map of bookId → Image for adjacent covers.
    // Prevents GC from discarding images before the user swipes,
    // and eagerly decodes so the bitmap is ready in GPU memory.
    let preloadedCovers = {};

    function preloadAdjacentBooks() {
      const books = getBooks();
      const currentIndex = books.findIndex(b => b.id === selectedBook.id);

      // Release previous preloads
      preloadedCovers = {};

      // Preload previous book cover
      if (currentIndex > 0) {
        const prevBook = books[currentIndex - 1];
        if (prevBook.coverUrl) {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.src = prevBook.coverUrl;
          if (img.decode) img.decode().catch(() => {});
          preloadedCovers[prevBook.id] = img;
        }
      }

      // Preload next book cover
      if (currentIndex < books.length - 1) {
        const nextBook = books[currentIndex + 1];
        if (nextBook.coverUrl) {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.src = nextBook.coverUrl;
          if (img.decode) img.decode().catch(() => {});
          preloadedCovers[nextBook.id] = img;
        }
      }
    }

    // Cube gesture state
    let cubeGestureActive = false;
    let cubeDirection = null; // 'left' or 'right'
    let cubeScene = null;
    let cubePerspective = 0;
    let cubeDragStartX = 0;
    let cubeDragStartY = 0;
    let cubeCurrentX = 0;
    let cubeWrapper = null;
    let cubeThreshold = 0;
    let cubeIsAnimating = false;
    let cubePrevBook = null;
    let cubeNextBook = null;
    let cubeHalfWidth = 0;

    // Swipe-down gesture state (Instagram Stories style)
    let swipeDownActive = false;
    let swipeDownCurrentY = 0;
    let swipeDownThreshold = 0;
    let swipeDownIsAnimating = false;

    // Track if touch started properly
    let touchStarted = false;

    function handleBookViewTouchStart(e) {
      if (currentView !== 'book') return;
      if (e.target.closest('.action-menu') || e.target.closest('.book-view-more-btn')) return;

      // Reset animation flags and clean up if they got stuck
      if (cubeIsAnimating || swipeDownIsAnimating) {
        cubeIsAnimating = false;
        swipeDownIsAnimating = false;
        if (cubeWrapper && cubeWrapper.parentNode) {
          cubeWrapper.remove();
          cubeWrapper = null;
          cubeScene = null;
        }
      }

      touchStarted = true;
      cubeDragStartX = e.touches[0].clientX;
      cubeDragStartY = e.touches[0].clientY;
      cubeCurrentX = 0;
      cubeGestureActive = false;
      cubeDirection = null;
      cubeThreshold = window.innerWidth * 0.28;
      cubeHalfWidth = window.innerWidth / 2;

      // Swipe-down initialization
      swipeDownActive = false;
      swipeDownCurrentY = 0;
      swipeDownThreshold = window.innerHeight * 0.25; // 25% of screen height

      // Get adjacent books
      const books = getBooks();
      const currentIndex = books.findIndex(b => b.id === selectedBook.id);
      cubePrevBook = currentIndex > 0 ? books[currentIndex - 1] : null;
      cubeNextBook = currentIndex < books.length - 1 ? books[currentIndex + 1] : null;
    }

    function handleBookViewTouchMove(e) {
      if (currentView !== 'book') return;
      if (!touchStarted) return; // touchstart didn't fire properly

      const touchX = e.touches[0].clientX;
      const touchY = e.touches[0].clientY;
      const deltaX = touchX - cubeDragStartX;
      const deltaY = touchY - cubeDragStartY;

      // Handle active swipe-down gesture first
      if (swipeDownActive) {
        e.preventDefault();
        swipeDownCurrentY = Math.max(0, deltaY); // Only allow downward movement

        const container = document.getElementById('book-view-container');
        const screenHeight = window.innerHeight;

        // Calculate progress (0 to 1)
        const progress = Math.min(swipeDownCurrentY / screenHeight, 1);

        // Progressive scale: 1.0 -> 0.92 as user drags
        const scale = 1 - (progress * 0.08);

        // Progressive opacity for home view behind: 0 -> 1
        const homeOpacity = Math.min(progress * 2, 1);

        // Apply transforms
        container.style.transform = `translateY(${swipeDownCurrentY}px) scale(${scale})`;
        container.style.borderRadius = `${progress * 16}px`;
        document.getElementById('home-view').style.opacity = homeOpacity;

        return;
      }

      // Handle active cube gesture
      if (cubeGestureActive) {
        e.preventDefault();
        cubeCurrentX = deltaX;

        // Limit drag range
        const maxDrag = window.innerWidth;
        if (cubeDirection === 'left') {
          cubeCurrentX = Math.max(Math.min(cubeCurrentX, 0), -maxDrag);
        } else {
          cubeCurrentX = Math.min(Math.max(cubeCurrentX, 0), maxDrag);
        }

        updateCubeRotation();
        return;
      }

      // Determine gesture direction (only if no gesture active yet)
      const absX = Math.abs(deltaX);
      const absY = deltaY; // We only care about downward (positive) for swipe-down

      // Need minimum movement to determine gesture type
      const totalMove = absX + Math.abs(deltaY);
      if (totalMove < 10) return;

      // Determine dominant direction
      // Swipe DOWN: moving downward and vertical is dominant
      if (deltaY > 0 && deltaY >= absX) {
        swipeDownActive = true;
        // Clear any entry animation that might conflict with transform
        const container = document.getElementById('book-view-container');
        container.style.animation = 'none';
        // Show home view behind
        document.getElementById('home-view').style.opacity = '0';
        document.getElementById('home-view').classList.add('active');
        e.preventDefault();
        return;
      }

      // Swipe LEFT/RIGHT: horizontal is dominant (or moving up)
      if (absX > Math.abs(deltaY) || deltaY < 0) {
        if (absX < 10) return; // need some horizontal movement for cube
        // Check if we can go in this direction
        if (deltaX < 0 && !cubeNextBook) return;
        if (deltaX > 0 && !cubePrevBook) return;

        cubeGestureActive = true;
        cubeDirection = deltaX < 0 ? 'left' : 'right';
        createCube(cubeDirection);
        e.preventDefault();
        return;
      }
    }

    let lastTouchEndTime = 0;

    function handleBookViewTouchEnd(e) {
      if (currentView !== 'book') return;

      // Reset touch tracking
      touchStarted = false;

      if (e.target.closest('.action-menu') || e.target.closest('.book-view-more-btn')) return;

      // Handle swipe-down gesture end
      if (swipeDownActive) {
        swipeDownActive = false;
        const passedThreshold = swipeDownCurrentY > swipeDownThreshold;

        if (passedThreshold) {
          completeSwipeDownExit();
        } else {
          snapBackSwipeDown();
        }
        return;
      }

      if (cubeGestureActive) {
        cubeGestureActive = false;
        const passedThreshold = Math.abs(cubeCurrentX) > cubeThreshold;

        if (passedThreshold) {
          completeCubeTransition();
        } else {
          snapBackCube();
        }
      } else if (!cubeIsAnimating && !swipeDownIsAnimating) {
        lastTouchEndTime = Date.now();
        handleBookViewTap();
      }
    }

    function completeSwipeDownExit() {
      swipeDownIsAnimating = true;
      const container = document.getElementById('book-view-container');
      const homeView = document.getElementById('home-view');
      const screenHeight = window.innerHeight;

      // Add transitions for smooth animation
      container.classList.add('swipe-exit');
      homeView.classList.add('swipe-fade');

      // Animate to fully off-screen
      container.style.transform = `translateY(${screenHeight}px) scale(0.9)`;
      container.style.opacity = '0';
      homeView.style.opacity = '1';

      setTimeout(() => {
        // Reset and complete transition
        container.classList.remove('swipe-exit');
        container.style.transform = '';
        container.style.opacity = '';
        container.style.borderRadius = '';
        homeView.classList.remove('swipe-fade');
        homeView.style.opacity = '';

        // Complete the view switch
        document.getElementById('book-view').classList.remove('active');
        currentView = 'home';
        selectedBook = null;
        renderTimeline();
        history.pushState({ view: 'home' }, '', '');

        swipeDownIsAnimating = false;
      }, 300);
    }

    function snapBackSwipeDown() {
      swipeDownIsAnimating = true;
      const container = document.getElementById('book-view-container');
      const homeView = document.getElementById('home-view');

      // Add transitions for smooth snap-back
      container.classList.add('swipe-transition');
      homeView.classList.add('swipe-fade');

      // Animate back to original position
      container.style.transform = 'translateY(0) scale(1)';
      container.style.borderRadius = '0';
      homeView.style.opacity = '0';

      setTimeout(() => {
        // Clean up
        container.classList.remove('swipe-transition');
        container.style.transform = '';
        container.style.borderRadius = '';
        homeView.classList.remove('swipe-fade', 'active');
        homeView.style.opacity = '';

        swipeDownIsAnimating = false;
      }, 350);
    }

    function handleBookViewClick(e) {
      if (currentView !== 'book') return;
      if (e.target.closest('.action-menu') || e.target.closest('.book-view-more-btn')) return;
      if (cubeIsAnimating || swipeDownIsAnimating) return;

      // Prevent double-toggle from touch + click on touch devices
      if (Date.now() - lastTouchEndTime < 300) return;

      if (actionMenuVisible) {
        hideActionMenu();
        return;
      }

      handleBookViewTap();
    }

    function handleBookViewTap() {
      toggleOverlay();
    }

    function createCube(direction) {
      const container = document.getElementById('book-view-container');
      const bookView = document.getElementById('book-view');
      const adjacentBook = direction === 'left' ? cubeNextBook : cubePrevBook;

      if (!adjacentBook) return;

      // No need to hide container — cube overlays it (same z-index, later in DOM order)

      // Calculate perspective - should be larger than the cube radius for realistic depth
      cubePerspective = cubeHalfWidth * 3;

      // Create cube wrapper
      cubeWrapper = document.createElement('div');
      cubeWrapper.className = 'cube-wrapper';
      cubeWrapper.id = 'cube-wrapper';
      cubeWrapper.style.perspective = `${cubePerspective}px`;
      cubeWrapper.style.perspectiveOrigin = '50% 50%';

      // Create cube scene (this rotates)
      cubeScene = document.createElement('div');
      cubeScene.className = 'cube-scene';
      cubeScene.id = 'cube-scene';

      // Create front face (current book) - positioned at Z = +halfWidth
      const frontFace = createCubeFace(selectedBook);
      frontFace.classList.add('cube-face-front');
      frontFace.style.transform = `translateZ(${cubeHalfWidth}px)`;

      // Create adjacent face - rotated 90deg and positioned on the side
      const adjacentFace = createCubeFace(adjacentBook);
      adjacentFace.classList.add('cube-face-adjacent');

      if (direction === 'left') {
        // Right side face (swiping left reveals it)
        adjacentFace.style.transform = `rotateY(90deg) translateZ(${cubeHalfWidth}px)`;
      } else {
        // Left side face (swiping right reveals it)
        adjacentFace.style.transform = `rotateY(-90deg) translateZ(${cubeHalfWidth}px)`;
      }

      cubeScene.appendChild(frontFace);
      cubeScene.appendChild(adjacentFace);
      cubeWrapper.appendChild(cubeScene);
      bookView.appendChild(cubeWrapper);

      // Initialize scene position (pushed back so front face is at screen plane)
      cubeScene.style.transform = `translateZ(-${cubeHalfWidth}px) rotateY(0deg)`;
    }

    function createCubeFace(book) {
      const face = document.createElement('div');
      face.className = 'cube-face';

      const coverUrl = book.coverUrl || 'https://via.placeholder.com/300x450/f0f0f0/999?text=No+Cover';

      // Background
      const bg = document.createElement('div');
      bg.className = 'book-view-bg';
      bg.style.backgroundImage = `url(${coverUrl})`;
      face.appendChild(bg);

      // Cover wrap
      const coverWrap = document.createElement('div');
      coverWrap.className = 'book-view-cover-wrap';

      const cover = document.createElement('img');
      cover.className = 'book-view-cover';
      cover.decoding = 'async';
      cover.crossOrigin = 'anonymous';
      cover.onload = () => {
        cover.classList.add('loaded');
        bg.classList.add('loaded');
      };
      cover.src = coverUrl;
      coverWrap.appendChild(cover);

      // Text boxes
      const textBoxes = book.textBoxes || (book.reflection ? [{
        text: book.reflection,
        x: book.textBoxX || 20,
        y: book.textBoxY || 300,
        color: book.textBoxColor || '#ffffff'
      }] : []);

      textBoxes.forEach(tb => {
        if (!tb.text) return;
        const textEl = document.createElement('div');
        textEl.className = 'book-view-text';
        const bgColor = tb.color || '#ffffff';
        const hasBg = bgColor && bgColor !== 'transparent' && bgColor !== 'rgba(0, 0, 0, 0)';
        const textColor = tb.textColor || (hasBg && isLightColorForCube(bgColor) ? '#1a1a1a' : '#ffffff');

        // Apply font style and size with backward compatibility
        const fontStyleIndex = tb.fontStyle !== undefined ? tb.fontStyle : 0;
        const fontSize = tb.fontSize || 16;
        const fontFamily = fontStyleIndex < FONT_STYLES.length ? FONT_STYLES[fontStyleIndex].family : FONT_STYLES[0].family;

        textEl.style.cssText = `
          display: block;
          left: ${tb.x}px;
          top: ${tb.y}px;
          background-color: ${hasBg ? bgColor : 'transparent'};
          color: ${textColor};
          font-family: ${fontFamily};
          font-size: ${fontSize}px;
        `;
        textEl.textContent = tb.text;
        coverWrap.appendChild(textEl);
      });

      face.appendChild(coverWrap);

      return face;
    }

    function updateCubeRotation() {
      if (!cubeScene) return;

      const screenWidth = window.innerWidth;
      const progress = cubeCurrentX / screenWidth;

      // Eased progress for smoother feel
      const absProgress = Math.abs(progress);
      const easedProgress = 1 - Math.pow(1 - absProgress, 2);
      const rotation = Math.sign(progress) * easedProgress * 90;

      // Rotate the cube scene
      cubeScene.style.transform = `translateZ(-${cubeHalfWidth}px) rotateY(${rotation}deg)`;
    }

    function completeCubeTransition() {
      cubeIsAnimating = true;
      const newBook = cubeDirection === 'left' ? cubeNextBook : cubePrevBook;
      const scene = cubeScene;
      const wrapper = cubeWrapper;

      // --- Swap book view content NOW, behind the opaque cube ---
      // The cube (z-index 61, background: #000) fully covers the viewport,
      // so this content swap is invisible. Starting now gives the browser
      // the entire 400ms rotation window to decode + paint the images in
      // the actual DOM elements (not just a preloaded Image object).
      selectedBook = newBook;
      overlayVisible = false;
      renderBookView(false, true);  // skipFade: sets src, no transitions

      // --- Decode the ACTUAL DOM <img>, not just a cached Image object ---
      // img.decode() resolves when the bitmap is ready for THIS element.
      // For cached/preloaded images this is near-instant; for uncached
      // images the 400ms rotation window gives time to finish.
      const bookViewCover = document.getElementById('book-view-cover');
      const domCoverReady = bookViewCover.decode
        ? bookViewCover.decode().catch(() => {})
        : Promise.resolve();

      // --- Animate cube rotation to 90 degrees ---
      scene.classList.add('cube-animate');
      const finalRotation = cubeDirection === 'left' ? -90 : 90;
      scene.style.transform = `translateZ(-${cubeHalfWidth}px) rotateY(${finalRotation}deg)`;

      // Wait for rotation CSS transition to finish
      const rotationDone = new Promise(resolve => {
        scene.addEventListener('transitionend', function onEnd(e) {
          if (e.target !== scene) return;
          scene.removeEventListener('transitionend', onEnd);
          resolve();
        }, { once: false });
      });

      // --- Wait for BOTH rotation AND actual DOM decode ---
      // The rotation takes 400ms; for preloaded images the DOM decode
      // resolves in <5ms. Promise.all ensures we never fade out the cube
      // before the cover is ready to be shown.
      Promise.all([rotationDone, domCoverReady]).then(() => {
        // Double rAF: first frame submits the decoded bitmap to the
        // compositor, second frame guarantees it has been painted to
        // screen. Only then do we fade out the cube.
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            wrapper.classList.add('cube-fade-out');

            wrapper.addEventListener('transitionend', function onFade(e) {
              if (e.target !== wrapper) return;
              wrapper.removeEventListener('transitionend', onFade);

              // Cube is now fully transparent — safe to remove
              if (wrapper.parentNode) {
                wrapper.remove();
              }
              cubeWrapper = null;
              cubeScene = null;
              cubeIsAnimating = false;
            }, { once: false });
          });
        });
      });
    }

    function snapBackCube() {
      cubeIsAnimating = true;
      const scene = cubeScene;
      const wrapper = cubeWrapper;

      // Add transition to the scene
      scene.classList.add('cube-animate');

      // Return to 0 degrees
      scene.style.transform = `translateZ(-${cubeHalfWidth}px) rotateY(0deg)`;

      // Wait for the CSS transition to actually finish
      scene.addEventListener('transitionend', function onEnd(e) {
        if (e.target !== scene) return;
        scene.removeEventListener('transitionend', onEnd);

        // Wait for paint, then remove cube
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            if (wrapper && wrapper.parentNode) {
              wrapper.remove();
            }
            cubeWrapper = null;
            cubeScene = null;

            cubeIsAnimating = false;
          });
        });
      }, { once: false });
    }

    function isLightColorForCube(hex) {
      if (!hex || hex.length < 7) return true;
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return (r * 299 + g * 587 + b * 114) / 1000 > 180;
    }

    function toggleOverlay() {
      overlayVisible = !overlayVisible;
      const infoEl = document.getElementById('book-view-info');
      const moreBtn = document.getElementById('book-view-more-btn');

      if (overlayVisible) {
        infoEl.classList.add('visible');
        moreBtn.classList.add('visible');
      } else {
        infoEl.classList.remove('visible');
        moreBtn.classList.remove('visible');
        hideActionMenu();
      }
    }

    function toggleActionMenu(e) {
      e.stopPropagation();
      if (actionMenuVisible) {
        hideActionMenu();
      } else {
        showActionMenu();
      }
    }

    function showActionMenu() {
      actionMenuVisible = true;
      document.getElementById('action-menu').classList.add('visible');
    }

    function hideActionMenu() {
      actionMenuVisible = false;
      document.getElementById('action-menu').classList.remove('visible');
    }

    // Tab switching
    function switchTab(tab) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

      if (tab === 'search') {
        document.querySelector('.tab:first-child').classList.add('active');
        document.getElementById('search-tab').classList.add('active');
      } else {
        document.querySelector('.tab:last-child').classList.add('active');
        document.getElementById('manual-tab').classList.add('active');
      }
    }

    // Render timeline (grouped by year)
    function renderTimeline() {
      const container = document.getElementById('timeline');
      const books = getBooks();

      if (books.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <h2>no books yet</h2>
            <p>tap + to begin your journal</p>
          </div>
        `;
        return;
      }

      // Group by year
      const grouped = {};
      books.forEach(book => {
        const year = book.yearRead || new Date(book.dateAdded).getFullYear().toString();
        if (!grouped[year]) grouped[year] = [];
        grouped[year].push(book);
      });

      // Sort years descending
      const sortedYears = Object.keys(grouped).sort((a, b) => b - a);

      let html = '';
      sortedYears.forEach(year => {
        html += `
          <div class="year-section" data-year="${year}">
            <div class="year-header">
              <div class="year-line"></div>
              <span class="year-text">${year}</span>
              <div class="year-line"></div>
            </div>
            <div class="year-grid">
              ${grouped[year].map(book => renderBookCard(book)).join('')}
            </div>
          </div>
        `;
      });

      container.innerHTML = html;
    }

    function renderBookCard(book) {
      const coverUrl = book.coverUrl || 'https://via.placeholder.com/128x192/f0f0f0/999?text=No+Cover';

      return `
        <div class="book-card" onclick='showBookView(${JSON.stringify(book).replace(/'/g, "&#39;")})'>
          <div class="card-inner">
            <img src="${coverUrl}" alt="${book.title}" class="card-cover" crossorigin="anonymous" onerror="this.removeAttribute('crossorigin');this.src='https://via.placeholder.com/128x192/f0f0f0/999?text=No+Cover'">
          </div>
          <div class="card-title">${book.title}</div>
          <div class="card-author">${book.author || 'Unknown Author'}</div>
        </div>
      `;
    }

    // Year indicator on scroll
    function setupYearIndicator() {
      const timeline = document.getElementById('timeline');
      const indicator = document.getElementById('year-indicator');
      let hideTimeout = null;

      // Listen on body element since body has overflow:auto and html has overflow:hidden
      document.body.addEventListener('scroll', () => {
        if (currentView !== 'home') return;

        const sections = timeline.querySelectorAll('.year-section');
        const scrollTop = document.body.scrollTop;

        // Don't show if at the very top
        if (scrollTop < 100) {
          indicator.classList.remove('visible');
          return;
        }

        // Find current year section
        let currentYear = null;
        sections.forEach(section => {
          const rect = section.getBoundingClientRect();
          if (rect.top <= 120) {
            currentYear = section.dataset.year;
          }
        });

        if (currentYear) {
          indicator.textContent = currentYear;
          indicator.classList.add('visible');

          // Hide after a delay
          if (hideTimeout) clearTimeout(hideTimeout);
          hideTimeout = setTimeout(() => {
            indicator.classList.remove('visible');
          }, 1500);
        }
      });
    }

    // Setup Edit View
    function setupEditView() {
      const coverWrap = document.getElementById('edit-cover-wrap');
      const textBox = document.getElementById('edit-text-box');
      const textInput = document.getElementById('edit-text-box-input');
      const saveBtn = document.querySelector('.edit-save-btn');

      // Tap on cover to create/show text box
      coverWrap.addEventListener('click', handleEditCoverTap);
      // Also handle touch for mobile
      coverWrap.addEventListener('touchend', (e) => {
        // Only handle if it's a single touch and not on a text box
        if (e.changedTouches.length === 1 &&
            !e.target.closest('.edit-text-box') &&
            !e.target.closest('.edit-text-static')) {
          // Create a synthetic click event for the tap
          const touch = e.changedTouches[0];
          handleEditCoverTap({
            target: e.target,
            clientX: touch.clientX,
            clientY: touch.clientY
          });
        }
      });

      // Save button touch/click handler
      saveBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        lastToolbarTouch = Date.now();
        handleSave();
      }, { passive: false });
      saveBtn.addEventListener('click', (e) => {
        if (Date.now() - lastToolbarTouch < 500) return;
        handleSave();
      });

      // Stories toolbar button touch handlers for mobile
      const fontStyleBtn = document.getElementById('font-style-btn');
      const textColorBtn = document.getElementById('text-color-btn');
      const bgColorBtn = document.getElementById('bg-color-btn');
      const eyedropperBtn = document.getElementById('eyedropper-btn');
      const doneBtn = document.getElementById('done-btn');

      fontStyleBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        lastToolbarTouch = Date.now();
        toggleFontPicker();
      }, { passive: false });
      fontStyleBtn.addEventListener('click', (e) => {
        if (Date.now() - lastToolbarTouch < 500) return;
        toggleFontPicker();
      });

      textColorBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        lastToolbarTouch = Date.now();
        toggleColorPicker('text');
      }, { passive: false });
      textColorBtn.addEventListener('click', (e) => {
        if (Date.now() - lastToolbarTouch < 500) return;
        toggleColorPicker('text');
      });

      bgColorBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        lastToolbarTouch = Date.now();
        toggleColorPicker('bg');
      }, { passive: false });
      bgColorBtn.addEventListener('click', (e) => {
        if (Date.now() - lastToolbarTouch < 500) return;
        toggleColorPicker('bg');
      });

      eyedropperBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        lastToolbarTouch = Date.now();
        toggleEyedropper();
      }, { passive: false });
      eyedropperBtn.addEventListener('click', (e) => {
        if (Date.now() - lastToolbarTouch < 500) return;
        toggleEyedropper();
      });

      doneBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        lastToolbarTouch = Date.now();
        dismissKeyboard();
      }, { passive: false });
      doneBtn.addEventListener('click', (e) => {
        if (Date.now() - lastToolbarTouch < 500) return;
        dismissKeyboard();
      });

      // Color swatch touch handler (event delegation)
      const paletteColors = document.getElementById('palette-colors');
      paletteColors.addEventListener('touchend', (e) => {
        const swatch = e.target.closest('.color-swatch');
        if (swatch) {
          e.preventDefault();
          e.stopPropagation();
          const color = swatch.style.background || swatch.style.backgroundColor;
          // Convert rgb to hex if needed
          const hexColor = color.startsWith('#') ? color : rgbStringToHex(color);
          applyColor(hexColor);
        }
      }, { passive: false });

      // Font option touch handler (event delegation)
      const fontPicker = document.getElementById('font-picker');
      fontPicker.addEventListener('touchend', (e) => {
        const option = e.target.closest('.font-option');
        if (option) {
          e.preventDefault();
          e.stopPropagation();
          const index = parseInt(option.dataset.index);
          selectFontStyle(index);
        }
      }, { passive: false });

      // Text input handling
      textInput.addEventListener('input', autoGrowTextarea);
      textInput.addEventListener('blur', handleEditTextBlur);
      textInput.addEventListener('focus', handleEditTextFocus);

      // Text box touch/mouse events for dragging
      textBox.addEventListener('touchstart', handleEditTextBoxTouchStart, { passive: false });
      textBox.addEventListener('touchmove', handleEditTextBoxTouchMove, { passive: false });
      textBox.addEventListener('touchend', handleEditTextBoxTouchEnd);
      textBox.addEventListener('mousedown', handleEditTextBoxMouseDown);
      document.addEventListener('mousemove', handleEditTextBoxMouseMove);
      document.addEventListener('mouseup', handleEditTextBoxMouseUp);

      // Click on text box display to enter edit mode
      textBox.addEventListener('click', handleEditTextBoxClick);

      // iOS keyboard fix: Do NOT sync container position to visualViewport.
      // On iOS Safari, the layout viewport (used by position:fixed) does not
      // change when the keyboard opens — only the visual viewport scrolls and
      // shrinks. Setting container.style.top to visualViewport.offsetTop would
      // push the fixed container down, causing the cover image to jump.
      // The correct approach: leave the container at top:0/bottom:0 and only
      // neutralise any residual window scroll iOS may trigger.
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', () => {
          if (currentView === 'edit') {
            // GUARD: only scroll reset — never set container position or size here.
            window.scrollTo(0, 0);
          }
        });
      }

      // Belt-and-suspenders: prevent window scroll during edit mode
      window.addEventListener('scroll', () => {
        if (currentView === 'edit') {
          window.scrollTo(0, 0);
        }
      });

      // iOS cover-jump fix, layer 3 of 3:
      // On older iOS (< 16) where overflow:clip is unsupported, the
      // container falls back to overflow:hidden — which still allows
      // programmatic scrolling (including iOS's internal scroll-into-view).
      // This listener catches any such scroll and immediately resets it,
      // preventing the cover image from shifting. On newer iOS where
      // overflow:clip is active, no scroll event can fire here at all,
      // so this listener is a silent no-op.
      coverWrap.addEventListener('scroll', () => {
        coverWrap.scrollTop = 0;
        coverWrap.scrollLeft = 0;
      });
    }

    // Render Edit View
    function renderEditView() {
      const book = selectedBook;
      const editCover = document.getElementById('edit-cover');
      const editCoverBg = document.getElementById('edit-cover-bg');
      const editCoverWrap = document.getElementById('edit-cover-wrap');
      const textBox = document.getElementById('edit-text-box');
      const textInput = document.getElementById('edit-text-box-input');
      const textDisplay = document.getElementById('edit-text-box-display');

      // Set cover image (only if different to avoid reload flicker)
      const coverUrl = book.coverUrl || 'https://via.placeholder.com/300x450/f0f0f0/999?text=No+Cover';
      const coverChanged = editCover.src !== coverUrl;

      if (coverChanged) {
        editCover.src = coverUrl;
        // Extract colors from cover when loaded
        editCover.onload = () => extractColorsFromCover(editCover);
      } else if (editCover.complete) {
        // Image already loaded, extract colors immediately
        extractColorsFromCover(editCover);
      }
      editCoverBg.style.backgroundImage = `url(${coverUrl})`;

      // Load existing text boxes (support both old and new format)
      if (book.textBoxes && book.textBoxes.length > 0) {
        editTextBoxes = book.textBoxes.map((tb, i) => ({
          id: i,
          text: tb.text,
          x: tb.x,
          y: tb.y,
          color: tb.color || '#ffffff',
          textColor: tb.textColor || null
        }));
      } else if (book.reflection) {
        editTextBoxes = [{
          id: 0,
          text: book.reflection,
          x: book.textBoxX || 20,
          y: book.textBoxY || 300,
          color: book.textBoxColor || '#ffffff',
          textColor: null
        }];
      } else {
        editTextBoxes = [];
      }

      // Hide color picker
      hideColorPicker();

      // Render all text boxes as static elements
      renderEditTextBoxes();

      // Hide the active text box editor initially
      textBox.style.display = 'none';
      textInput.value = '';
      textDisplay.textContent = '';
      currentTextBoxId = null;

      isEditing = false;
      isDragging = false;
    }

    function renderEditTextBoxes() {
      const editCoverWrap = document.getElementById('edit-cover-wrap');

      // Remove existing static text boxes
      editCoverWrap.querySelectorAll('.edit-text-static').forEach(el => el.remove());

      // Render each text box
      editTextBoxes.forEach(tb => {
        if (!tb.text) return;
        const el = document.createElement('div');
        el.className = 'edit-text-static edit-text-box draggable';
        el.dataset.id = tb.id;
        el.style.left = tb.x + 'px';
        el.style.top = tb.y + 'px';

        // Apply background color (support transparent)
        const bgColor = tb.color || '#ffffff';
        const hasBg = bgColor && bgColor !== 'transparent' && bgColor !== 'rgba(0, 0, 0, 0)';
        el.style.backgroundColor = bgColor;
        if (!hasBg) el.classList.add('no-bg');

        const textColor = tb.textColor || (hasBg && isLightColor(bgColor) ? '#1a1a1a' : '#ffffff');
        el.style.color = textColor;

        // Apply font style and size with backward compatibility
        const fontStyleIndex = tb.fontStyle !== undefined ? tb.fontStyle : 0;
        const fontSize = tb.fontSize || DEFAULT_FONT_SIZE;
        const fontFamily = FONT_STYLES[fontStyleIndex] ? FONT_STYLES[fontStyleIndex].family : FONT_STYLES[0].family;
        el.style.setProperty('--text-box-font', fontFamily);
        el.style.setProperty('--text-box-font-size', fontSize + 'px');

        el.innerHTML = `<div class="edit-text-box-display" style="display:block;font-family:${fontFamily};font-size:${fontSize}px;">${tb.text}</div>`;
        el.addEventListener('click', (e) => handleStaticTextBoxClick(e, tb.id));
        el.addEventListener('touchstart', (e) => handleStaticTextBoxTouchStart(e, tb.id), { passive: false });
        el.addEventListener('touchmove', handleStaticTextBoxTouchMove, { passive: false });
        el.addEventListener('touchend', handleStaticTextBoxTouchEnd);
        el.addEventListener('mousedown', (e) => handleStaticTextBoxMouseDown(e, tb.id));
        editCoverWrap.appendChild(el);
      });
    }

    function handleStaticTextBoxClick(e, id) {
      e.stopPropagation();
      if (!isDragging) {
        activateTextBox(id);
      }
    }

    function handleStaticTextBoxTouchStart(e, id) {
      if (currentView !== 'edit') return;
      e.stopPropagation();

      const tb = editTextBoxes.find(t => t.id === id);
      if (!tb) return;

      // Check for pinch gesture (two fingers)
      if (e.touches.length === 2) {
        isPinching = true;
        isDragging = false;
        pinchStartDistance = getPinchDistance(e.touches);
        pinchStartFontSize = tb.fontSize || DEFAULT_FONT_SIZE;
        currentTextBoxId = id;
        e.preventDefault();
        return;
      }

      const touch = e.touches[0];
      currentTextBoxId = id;
      textBoxX = tb.x;
      textBoxY = tb.y;
      textBoxStartX = tb.x;
      textBoxStartY = tb.y;
      dragStartX = touch.clientX;
      dragStartY = touch.clientY;
      dragStartDistance = 0;
      isDragging = false;
      coverWrapRect = document.getElementById('edit-cover-wrap').getBoundingClientRect();
    }

    function handleStaticTextBoxTouchMove(e) {
      if (currentView !== 'edit') return;

      // Handle pinch-to-resize
      if (isPinching && e.touches.length === 2) {
        e.preventDefault();
        const currentDistance = getPinchDistance(e.touches);
        const scale = currentDistance / pinchStartDistance;
        let newFontSize = Math.round(pinchStartFontSize * scale);
        newFontSize = Math.max(MIN_FONT_SIZE, Math.min(MAX_FONT_SIZE, newFontSize));

        // Update the static element's font size
        const el = e.target.closest('.edit-text-static');
        if (el) {
          el.style.setProperty('--text-box-font-size', newFontSize + 'px');
          const displayEl = el.querySelector('.edit-text-box-display');
          if (displayEl) {
            displayEl.style.fontSize = newFontSize + 'px';
          }
        }

        // Update in array
        const tb = editTextBoxes.find(t => t.id === currentTextBoxId);
        if (tb) {
          tb.fontSize = newFontSize;
        }
        currentFontSize = newFontSize;
        return;
      }

      const touch = e.touches[0];
      const deltaX = touch.clientX - dragStartX;
      const deltaY = touch.clientY - dragStartY;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

      // Start dragging only after movement threshold (10px)
      if (!isDragging && distance > 10) {
        isDragging = true;
        const el = e.target.closest('.edit-text-static');
        if (el) el.style.opacity = '0.8';
        document.getElementById('edit-trash').classList.add('visible');
      }

      if (!isDragging) return;
      e.preventDefault();

      let newX = textBoxStartX + deltaX;
      let newY = textBoxStartY + deltaY;

      const el = e.target.closest('.edit-text-static');
      const maxX = coverWrapRect.width - el.offsetWidth - 10;
      const maxY = coverWrapRect.height - el.offsetHeight - 80;
      newX = Math.max(10, Math.min(newX, maxX));
      newY = Math.max(10, Math.min(newY, maxY));

      textBoxX = newX;
      textBoxY = newY;
      el.style.left = newX + 'px';
      el.style.top = newY + 'px';

      // Update in array
      const tb = editTextBoxes.find(t => t.id === currentTextBoxId);
      if (tb) {
        tb.x = newX;
        tb.y = newY;
      }

      checkTrashHover(touch.clientX, touch.clientY);
    }

    function handleStaticTextBoxTouchEnd(e) {
      const wasDragging = isDragging;
      const wasPinching = isPinching;
      const id = currentTextBoxId;

      const trash = document.getElementById('edit-trash');
      const el = e.target.closest('.edit-text-static');

      if (wasDragging && trash.classList.contains('active')) {
        // Delete this text box
        editTextBoxes = editTextBoxes.filter(tb => tb.id !== currentTextBoxId);
        el.remove();
      } else if (el) {
        el.style.opacity = '1';
      }

      trash.classList.remove('visible', 'active');
      isDragging = false;
      isPinching = false;
      coverWrapRect = null;

      // Handle tap (no drag, no pinch) - activate the text box
      if (!wasDragging && !wasPinching && id !== null) {
        e.preventDefault();
        activateTextBox(id);
      }
    }

    // Helper function to calculate distance between two touch points
    function getPinchDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function handleStaticTextBoxMouseDown(e, id) {
      if (currentView !== 'edit') return;
      e.preventDefault();

      const tb = editTextBoxes.find(t => t.id === id);
      if (!tb) return;

      currentTextBoxId = id;
      textBoxX = tb.x;
      textBoxY = tb.y;
      textBoxStartX = tb.x;
      textBoxStartY = tb.y;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      coverWrapRect = document.getElementById('edit-cover-wrap').getBoundingClientRect();
      isDragging = true;
      e.target.closest('.edit-text-static').style.opacity = '0.8';
      document.getElementById('edit-trash').classList.add('visible');
    }

    function activateTextBox(id) {
      const tb = editTextBoxes.find(t => t.id === id);
      if (!tb) return;

      const textBox = document.getElementById('edit-text-box');
      const textInput = document.getElementById('edit-text-box-input');
      const textDisplay = document.getElementById('edit-text-box-display');

      // Save current text box first if there's one active
      if (textBox.style.display !== 'none' && currentTextBoxId !== null && currentTextBoxId !== id) {
        saveCurrentTextBoxToArray();
      }

      // Re-render all static text boxes (to show the previously active one)
      renderEditTextBoxes();

      // Hide the static element for the one we're activating
      const staticEl = document.querySelector(`.edit-text-static[data-id="${id}"]`);
      if (staticEl) staticEl.style.display = 'none';

      // Show active text box
      currentTextBoxId = id;
      textBoxX = tb.x;
      textBoxY = tb.y;
      textInput.value = tb.text;
      textDisplay.textContent = tb.text;
      textBox.style.display = 'block';
      textBox.style.left = tb.x + 'px';
      textBox.style.top = tb.y + 'px';

      // Apply colors
      const bgColor = tb.color || '#ffffff';
      const hasBg = bgColor && bgColor !== 'transparent' && bgColor !== 'rgba(0, 0, 0, 0)';
      textBox.style.backgroundColor = bgColor;
      textBox.classList.toggle('no-bg', !hasBg);
      const textColor = tb.textColor || (isLightColor(bgColor) ? '#1a1a1a' : '#ffffff');
      textBox.style.color = textColor;

      // Apply font style and size (with backward compatibility defaults)
      currentFontStyleIndex = tb.fontStyle !== undefined ? tb.fontStyle : 0;
      currentFontSize = tb.fontSize || DEFAULT_FONT_SIZE;
      textBox.style.setProperty('--text-box-font', FONT_STYLES[currentFontStyleIndex].family);
      textBox.style.setProperty('--text-box-font-size', currentFontSize + 'px');

      // Show toolbar
      showColorToolbar();

      showEditDisplayMode();
    }

    function handleEditCoverTap(e) {
      if (currentView !== 'edit') return;

      // Ignore if tapping on text box, save button, or toolbar/pickers
      if (e.target.closest('.edit-text-box')) return;
      if (e.target.closest('.edit-save-btn')) return;
      if (e.target.closest('.stories-toolbar')) return;
      if (e.target.closest('.color-picker')) return;
      if (e.target.closest('.font-picker')) return;

      const textBox = document.getElementById('edit-text-box');
      const textInput = document.getElementById('edit-text-box-input');
      const coverWrap = document.getElementById('edit-cover-wrap');

      // If currently editing, exit edit mode (blur handles the rest)
      if (isEditing) {
        textInput.blur();
        return;
      }

      // If active text box is visible, save it and hide it first
      if (textBox.style.display !== 'none') {
        saveCurrentTextBoxToArray();
        textBox.style.display = 'none';
        textInput.value = '';
        document.getElementById('edit-text-box-display').textContent = '';
        renderEditTextBoxes();
        hideColorToolbar();
      }

      // Create new text box at exact tap position (no offset)
      const rect = coverWrap.getBoundingClientRect();
      textBoxX = e.clientX - rect.left;
      textBoxY = e.clientY - rect.top;

      // Constrain position to keep text box visible
      textBoxX = Math.max(10, Math.min(textBoxX, rect.width - 60));
      textBoxY = Math.max(60, Math.min(textBoxY, rect.height - 100));

      // Generate new ID for this text box
      const maxId = editTextBoxes.reduce((max, tb) => Math.max(max, tb.id), -1);
      currentTextBoxId = maxId + 1;

      // Reset font style and size for new text box
      currentFontStyleIndex = 0;
      currentFontSize = DEFAULT_FONT_SIZE;

      textBox.style.left = textBoxX + 'px';
      textBox.style.top = textBoxY + 'px';
      textBox.style.display = 'block';
      textBox.style.backgroundColor = 'transparent';
      textBox.style.color = '#000000';
      textBox.classList.add('no-bg');
      textBox.style.setProperty('--text-box-font', FONT_STYLES[currentFontStyleIndex].family);
      textBox.style.setProperty('--text-box-font-size', currentFontSize + 'px');

      // Set small initial size for empty text box
      textInput.style.width = '2px';
      textInput.style.height = Math.round(currentFontSize * 1.4) + 'px';
      textInput.style.minWidth = '0';

      // Show toolbar immediately
      showColorToolbar();

      // Enter edit mode and focus immediately to show keyboard.
      // iOS cover-jump fix, layer 2 of 3:
      // preventScroll tells the browser not to scroll any ancestor
      // to bring the textarea into view. Without it, iOS WebKit scrolls
      // .edit-cover-wrap (shifting the cover) even before overflow:clip
      // or the scroll listener can intervene.
      showEditInputMode();
      textInput.focus({ preventScroll: true });
    }

    function showEditInputMode() {
      const textBox = document.getElementById('edit-text-box');
      const textInput = document.getElementById('edit-text-box-input');
      const textDisplay = document.getElementById('edit-text-box-display');

      isEditing = true;
      textBox.classList.add('editing');
      textBox.classList.remove('draggable');

      // Only set dimensions if there's existing content
      if (textInput.value.trim()) {
        const displayRect = textDisplay.getBoundingClientRect();
        const currentWidth = displayRect.width;
        const currentHeight = displayRect.height || 22;
        textInput.style.width = currentWidth + 'px';
        textInput.style.height = currentHeight + 'px';
      }
      textInput.style.minWidth = '0';

      textInput.style.display = 'block';
      textDisplay.style.display = 'none';
    }

    function showEditDisplayMode() {
      const textBox = document.getElementById('edit-text-box');
      const textInput = document.getElementById('edit-text-box-input');
      const textDisplay = document.getElementById('edit-text-box-display');

      isEditing = false;
      textBox.classList.remove('editing');
      textBox.classList.add('draggable');
      textInput.style.display = 'none';
      textDisplay.style.display = 'block';
      textDisplay.textContent = textInput.value;

      // Reset textarea size constraints
      textInput.style.width = '';
      textInput.style.height = '';
    }

    function autoGrowTextarea() {
      const textInput = document.getElementById('edit-text-box-input');
      const textBox = document.getElementById('edit-text-box');
      const coverWrap = document.getElementById('edit-cover-wrap');

      // Get current font style and size from CSS variables
      const computedStyle = getComputedStyle(textBox);
      const fontFamily = computedStyle.getPropertyValue('--text-box-font') || FONT_STYLES[0].family;
      const fontSize = parseInt(computedStyle.getPropertyValue('--text-box-font-size')) || currentFontSize || DEFAULT_FONT_SIZE;

      // Calculate max width (container width minus margins and padding)
      const containerWidth = coverWrap.offsetWidth;
      const maxWidth = containerWidth - 20 - 28; // 10px margin each side, 28px padding

      // Create a temporary span to measure text width with current font
      const measureSpan = document.createElement('span');
      measureSpan.style.cssText = `
        font-family: ${fontFamily};
        font-size: ${fontSize}px;
        letter-spacing: 0.5px;
        white-space: pre;
        visibility: hidden;
        position: absolute;
      `;
      measureSpan.textContent = textInput.value || ' ';
      document.body.appendChild(measureSpan);

      // Get measured width and apply (with some buffer)
      let newWidth = Math.min(measureSpan.offsetWidth + 4, maxWidth);
      newWidth = Math.max(newWidth, 2); // minimum width

      document.body.removeChild(measureSpan);

      textInput.style.width = newWidth + 'px';

      // Calculate line height based on font size
      const lineHeight = Math.round(fontSize * 1.4);
      const lines = Math.max(1, Math.ceil(textInput.scrollHeight / lineHeight));
      textInput.style.height = (lines * lineHeight) + 'px';
    }

    function handleEditTextFocus() {
      // Just mark as editing, no visual changes
      isEditing = true;
    }

    function handleEditTextBoxClick(e) {
      if (currentView !== 'edit') return;
      // If not currently editing, enter edit mode
      if (!isEditing) {
        e.stopPropagation();
        showEditInputMode();
        // preventScroll: see iOS cover-jump fix layer 2 in handleEditCoverTap
        document.getElementById('edit-text-box-input').focus({ preventScroll: true });
      }
    }

    function handleEditTextBlur() {
      const textInput = document.getElementById('edit-text-box-input');
      const textBox = document.getElementById('edit-text-box');

      isEditing = false;

      if (textInput.value.trim()) {
        showEditDisplayMode();
        // Save the current text box to the array
        saveCurrentTextBoxToArray();
        // Hide active box and render all as static
        textBox.style.display = 'none';
        textInput.value = '';
        document.getElementById('edit-text-box-display').textContent = '';
        renderEditTextBoxes();
        currentTextBoxId = null;
        hideColorToolbar();
      } else {
        // No text, hide the box and remove from array if it existed
        if (currentTextBoxId !== null) {
          editTextBoxes = editTextBoxes.filter(tb => tb.id !== currentTextBoxId);
        }
        textBox.style.display = 'none';
        currentTextBoxId = null;
        hideColorToolbar();
      }
    }

    // Save the currently active text box to editTextBoxes array
    function saveCurrentTextBoxToArray() {
      if (currentTextBoxId === null) return;

      const textInput = document.getElementById('edit-text-box-input');
      const textBox = document.getElementById('edit-text-box');
      const text = textInput.value.trim();

      if (!text) return;

      // Get current colors from the active text box
      const bgColor = textBox.style.backgroundColor || '#ffffff';
      const textColor = textBox.style.color || null;

      const existingIndex = editTextBoxes.findIndex(tb => tb.id === currentTextBoxId);

      if (existingIndex !== -1) {
        // Update existing text box
        editTextBoxes[existingIndex].text = text;
        editTextBoxes[existingIndex].x = textBoxX;
        editTextBoxes[existingIndex].y = textBoxY;
        editTextBoxes[existingIndex].color = bgColor;
        editTextBoxes[existingIndex].textColor = textColor;
        editTextBoxes[existingIndex].fontStyle = currentFontStyleIndex;
        editTextBoxes[existingIndex].fontSize = currentFontSize;
      } else {
        // Add new text box
        editTextBoxes.push({
          id: currentTextBoxId,
          text: text,
          x: textBoxX,
          y: textBoxY,
          color: bgColor,
          textColor: textColor,
          fontStyle: currentFontStyleIndex,
          fontSize: currentFontSize
        });
      }
    }

    // Color picker functions
    function extractColorsFromCover(img) {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const size = 50;
        canvas.width = size;
        canvas.height = size;
        ctx.drawImage(img, 0, 0, size, size);

        const imageData = ctx.getImageData(0, 0, size, size).data;
        const colorCounts = {};

        for (let i = 0; i < imageData.length; i += 16) {
          const r = Math.round(imageData[i] / 32) * 32;
          const g = Math.round(imageData[i + 1] / 32) * 32;
          const b = Math.round(imageData[i + 2] / 32) * 32;
          const hex = rgbToHex(r, g, b);
          colorCounts[hex] = (colorCounts[hex] || 0) + 1;
        }

        extractedColors = Object.entries(colorCounts)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 6)
          .map(([color]) => color);

        renderColorSwatches();
      } catch (e) {
        extractedColors = [];
        renderColorSwatches();
      }
    }

    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => {
        const hex = Math.min(255, Math.max(0, x)).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }

    function renderColorSwatches() {
      const extractedSection = document.getElementById('extracted-colors-section');
      const extractedContainer = document.getElementById('extracted-colors');
      const paletteContainer = document.getElementById('palette-colors');

      // Show extracted colors from cover (if any)
      if (extractedColors.length > 0) {
        extractedSection.style.display = 'block';
        extractedContainer.innerHTML = extractedColors.map(color =>
          `<div class="color-swatch ${isLightColor(color) ? 'light' : ''}" style="background: ${color}" onclick="applyColor('${color}')"></div>`
        ).join('');
      } else {
        extractedSection.style.display = 'none';
      }

      // Show standard palette
      paletteContainer.innerHTML = appPalette.map(color =>
        `<div class="color-swatch ${isLightColor(color) ? 'light' : ''}" style="background: ${color}" onclick="applyColor('${color}')"></div>`
      ).join('');
    }

    function isLightColor(hex) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      return brightness > 180;
    }

    function rgbStringToHex(rgb) {
      // Handle both "rgb(r, g, b)" and "rgba(r, g, b, a)" formats
      const match = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!match) return rgb;
      const r = parseInt(match[1]).toString(16).padStart(2, '0');
      const g = parseInt(match[2]).toString(16).padStart(2, '0');
      const b = parseInt(match[3]).toString(16).padStart(2, '0');
      return `#${r}${g}${b}`;
    }

    function toggleColorPicker(mode) {
      const picker = document.getElementById('color-picker');
      const textBtn = document.getElementById('text-color-btn');
      const bgBtn = document.getElementById('bg-color-btn');

      // Hide font picker if open
      hideFontPicker();

      if (colorPickerMode === mode) {
        hideColorPicker();
      } else {
        colorPickerMode = mode;
        picker.classList.add('visible');
        textBtn.classList.toggle('active', mode === 'text');
        bgBtn.classList.toggle('active', mode === 'bg');
      }
    }

    function hideColorPicker() {
      colorPickerMode = null;
      document.getElementById('color-picker').classList.remove('visible');
      const textBtn = document.getElementById('text-color-btn');
      const bgBtn = document.getElementById('bg-color-btn');
      if (textBtn) textBtn.classList.remove('active');
      if (bgBtn) bgBtn.classList.remove('active');
    }

    function toggleFontPicker() {
      const picker = document.getElementById('font-picker');
      const fontBtn = document.getElementById('font-style-btn');

      // Hide color picker if open
      hideColorPicker();

      if (picker.classList.contains('visible')) {
        hideFontPicker();
      } else {
        picker.classList.add('visible');
        fontBtn.classList.add('active');
        updateFontPickerSelection();
      }
    }

    function hideFontPicker() {
      document.getElementById('font-picker').classList.remove('visible');
      document.getElementById('font-style-btn').classList.remove('active');
    }

    function updateFontPickerSelection() {
      const options = document.querySelectorAll('.font-option');
      options.forEach((opt, index) => {
        opt.classList.toggle('selected', index === currentFontStyleIndex);
      });
    }

    function selectFontStyle(index) {
      currentFontStyleIndex = index;
      applyCurrentFontStyle();
      updateToolbarState();
      updateFontPickerSelection();
      hideFontPicker();
    }

    function applyColor(color) {
      if (currentTextBoxId === null) {
        hideColorPicker();
        return;
      }

      const tb = editTextBoxes.find(t => t.id === currentTextBoxId);
      if (!tb) return;

      // Also set eyedropperMode so eyedropper knows what to apply
      eyedropperMode = colorPickerMode;

      if (colorPickerMode === 'bg') {
        tb.color = color;
      } else if (colorPickerMode === 'text') {
        tb.textColor = color;
      }

      // Update active text box display
      const textBox = document.getElementById('edit-text-box');
      if (textBox.style.display !== 'none') {
        if (colorPickerMode === 'bg') {
          textBox.style.backgroundColor = color;
          textBox.classList.remove('no-bg');
          // Auto-set text color if not manually set
          if (!tb.textColor) {
            const autoTextColor = isLightColor(color) ? '#1a1a1a' : '#ffffff';
            textBox.style.color = autoTextColor;
          }
        } else if (colorPickerMode === 'text') {
          textBox.style.color = color;
        }
      }

      // Update static text box if visible
      const staticEl = document.querySelector(`.edit-text-static[data-id="${currentTextBoxId}"]`);
      if (staticEl) {
        if (colorPickerMode === 'bg') {
          staticEl.style.backgroundColor = color;
          staticEl.classList.remove('no-bg');
          if (!tb.textColor) {
            staticEl.style.color = isLightColor(color) ? '#1a1a1a' : '#ffffff';
          }
        } else if (colorPickerMode === 'text') {
          staticEl.style.color = color;
        }
      }

      hideColorPicker();
      updateToolbarState();
    }

    function showColorToolbar() {
      document.getElementById('stories-toolbar').classList.add('visible');
      updateToolbarState();
    }

    function hideColorToolbar() {
      document.getElementById('stories-toolbar').classList.remove('visible');
      hideColorPicker();
      hideFontPicker();
      hideEyedropper();
    }

    function updateToolbarState() {
      // Update text color indicator
      const textBox = document.getElementById('edit-text-box');
      const textColorIndicator = document.getElementById('text-color-indicator');
      if (textColorIndicator) {
        const textColor = textBox.style.color || '#1a1a1a';
        textColorIndicator.style.background = textColor;
      }

      // Update font preview based on current style
      const fontPreview = document.querySelector('#font-style-btn .font-preview');
      if (fontPreview) {
        fontPreview.style.fontFamily = FONT_STYLES[currentFontStyleIndex].family;
      }

      // Update background color indicator
      const bgBtn = document.getElementById('bg-color-btn');
      const highlightIcon = bgBtn.querySelector('.highlight-icon');
      if (highlightIcon) {
        const bgColor = textBox.style.backgroundColor;
        const hasBg = bgColor && bgColor !== 'transparent' && bgColor !== 'rgba(0, 0, 0, 0)';
        if (hasBg) {
          highlightIcon.style.background = bgColor;
          // Set text color for visibility
          highlightIcon.style.color = isLightColor(rgbStringToHex(bgColor)) ? '#1a1a1a' : '#ffffff';
        } else {
          highlightIcon.style.background = 'rgba(255, 255, 255, 0.3)';
          highlightIcon.style.color = '#fff';
        }
      }
    }

    function applyCurrentFontStyle() {
      const textBox = document.getElementById('edit-text-box');
      const fontFamily = FONT_STYLES[currentFontStyleIndex].family;
      textBox.style.setProperty('--text-box-font', fontFamily);

      // Update the current text box in array if it exists
      if (currentTextBoxId !== null) {
        const tb = editTextBoxes.find(t => t.id === currentTextBoxId);
        if (tb) {
          tb.fontStyle = currentFontStyleIndex;
        }
      }
    }

    // Done button - save text box, close pickers, hide toolbar
    function dismissKeyboard() {
      hideColorPicker();
      hideFontPicker();

      const textInput = document.getElementById('edit-text-box-input');
      const textBox = document.getElementById('edit-text-box');

      // If text input has focus, blur it (will trigger handleEditTextBlur)
      if (document.activeElement === textInput) {
        textInput.blur();
        return;
      }

      // Otherwise, manually save and close
      isEditing = false;

      if (textInput.value.trim()) {
        saveCurrentTextBoxToArray();
        textBox.style.display = 'none';
        textInput.value = '';
        document.getElementById('edit-text-box-display').textContent = '';
        renderEditTextBoxes();
        currentTextBoxId = null;
      } else if (currentTextBoxId !== null) {
        // No text, remove empty text box
        editTextBoxes = editTextBoxes.filter(tb => tb.id !== currentTextBoxId);
        textBox.style.display = 'none';
        currentTextBoxId = null;
      }

      hideColorToolbar();
    }

    // Eyedropper functions
    function toggleEyedropper() {
      // If touch eyedropper is active, deactivate it
      if (eyedropperActive) {
        deactivateTouchEyedropper();
        return;
      }

      // Use native EyeDropper API if available (desktop Chrome/Edge)
      if ('EyeDropper' in window) {
        useNativeEyedropper();
      } else {
        // Mobile fallback: touch-based eyedropper on the cover
        activateTouchEyedropper();
      }
    }

    async function useNativeEyedropper() {
      // Use the current colorPickerMode if a picker is open, otherwise use last eyedropperMode
      if (colorPickerMode) {
        eyedropperMode = colorPickerMode;
      }
      // Default to 'text' if no mode has been set
      if (!eyedropperMode) {
        eyedropperMode = 'text';
      }
      hideColorPicker();
      hideFontPicker();

      const eyedropperBtn = document.getElementById('eyedropper-btn');
      eyedropperBtn.classList.add('active');

      try {
        const eyeDropper = new EyeDropper();
        const result = await eyeDropper.open();
        const color = result.sRGBHex;

        // Apply color to current text box
        if (currentTextBoxId !== null) {
          const tb = editTextBoxes.find(t => t.id === currentTextBoxId);
          if (tb) {
            const textBox = document.getElementById('edit-text-box');
            const staticEl = document.querySelector(`.edit-text-static[data-id="${currentTextBoxId}"]`);

            if (eyedropperMode === 'bg') {
              tb.color = color;
              if (textBox.style.display !== 'none') {
                textBox.style.backgroundColor = color;
                textBox.classList.remove('no-bg');
                if (!tb.textColor) {
                  textBox.style.color = isLightColor(color) ? '#1a1a1a' : '#ffffff';
                }
              }
              if (staticEl) {
                staticEl.style.backgroundColor = color;
                staticEl.classList.remove('no-bg');
                if (!tb.textColor) {
                  staticEl.style.color = isLightColor(color) ? '#1a1a1a' : '#ffffff';
                }
              }
            } else if (eyedropperMode === 'text') {
              tb.textColor = color;
              if (textBox.style.display !== 'none') {
                textBox.style.color = color;
              }
              if (staticEl) {
                staticEl.style.color = color;
              }
            }
            updateToolbarState();
          }
        }
      } catch (e) {
        // User cancelled or error occurred
        console.log('Eyedropper cancelled or failed:', e);
      }

      eyedropperBtn.classList.remove('active');
    }

    function showEyedropper() {
      // Legacy function - now redirects to native eyedropper
      toggleEyedropper();
    }

    function hideEyedropper() {
      if (eyedropperActive) {
        deactivateTouchEyedropper();
      } else {
        eyedropperActive = false;
        const eyedropperBtn = document.getElementById('eyedropper-btn');
        if (eyedropperBtn) eyedropperBtn.classList.remove('active');
      }
    }

    // Touch-based eyedropper for mobile (iOS Safari etc.)
    function activateTouchEyedropper() {
      if (colorPickerMode) {
        eyedropperMode = colorPickerMode;
      }
      if (!eyedropperMode) {
        eyedropperMode = 'text';
      }
      hideColorPicker();
      hideFontPicker();

      const editCover = document.getElementById('edit-cover');
      if (!editCover.complete || !editCover.naturalWidth) return;

      // Create canvas for pixel sampling
      try {
        eyedropperCanvas = document.createElement('canvas');
        eyedropperCtx = eyedropperCanvas.getContext('2d');
        eyedropperCanvas.width = editCover.naturalWidth;
        eyedropperCanvas.height = editCover.naturalHeight;
        eyedropperCtx.drawImage(editCover, 0, 0);
        // Test that canvas is not tainted
        eyedropperCtx.getImageData(0, 0, 1, 1);
      } catch (e) {
        // Canvas is tainted (CORS), fall back to color picker
        eyedropperCanvas = null;
        eyedropperCtx = null;
        toggleColorPicker(eyedropperMode || 'text');
        return;
      }

      eyedropperActive = true;
      eyedropperPickedColor = null;

      const overlay = document.getElementById('eyedropper-overlay');
      const eyedropperBtn = document.getElementById('eyedropper-btn');

      overlay.classList.add('active');
      eyedropperBtn.classList.add('active');

      overlay.addEventListener('touchstart', eyedropperTouchStart, { passive: false });
      overlay.addEventListener('touchmove', eyedropperTouchMove, { passive: false });
      overlay.addEventListener('touchend', eyedropperTouchEnd);
      overlay.addEventListener('touchcancel', eyedropperTouchCancel);

      // Mouse events for desktop browsers without native EyeDropper API
      overlay.addEventListener('mousedown', eyedropperMouseDown);
      overlay.addEventListener('mousemove', eyedropperMouseMove);
      overlay.addEventListener('mouseup', eyedropperMouseUp);
    }

    let eyedropperMouseIsDown = false;

    function eyedropperTouchStart(e) {
      e.preventDefault();
      const touch = e.touches[0];
      sampleEyedropperColor(touch.clientX, touch.clientY);
      updateEyedropperPreview(touch.clientX, touch.clientY);
    }

    function eyedropperTouchMove(e) {
      e.preventDefault();
      const touch = e.touches[0];
      sampleEyedropperColor(touch.clientX, touch.clientY);
      updateEyedropperPreview(touch.clientX, touch.clientY);
    }

    function eyedropperTouchEnd(e) {
      if (eyedropperPickedColor && currentTextBoxId !== null) {
        applyEyedropperColor(eyedropperPickedColor);
      }
      deactivateTouchEyedropper();
    }

    function eyedropperTouchCancel() {
      deactivateTouchEyedropper();
    }

    function eyedropperMouseDown(e) {
      e.preventDefault();
      eyedropperMouseIsDown = true;
      sampleEyedropperColor(e.clientX, e.clientY);
      updateEyedropperPreview(e.clientX, e.clientY);
    }

    function eyedropperMouseMove(e) {
      if (!eyedropperMouseIsDown) return;
      e.preventDefault();
      sampleEyedropperColor(e.clientX, e.clientY);
      updateEyedropperPreview(e.clientX, e.clientY);
    }

    function eyedropperMouseUp(e) {
      eyedropperMouseIsDown = false;
      if (eyedropperPickedColor && currentTextBoxId !== null) {
        applyEyedropperColor(eyedropperPickedColor);
      }
      deactivateTouchEyedropper();
    }

    function sampleEyedropperColor(clientX, clientY) {
      if (!eyedropperCanvas || !eyedropperCtx) return;

      const editCover = document.getElementById('edit-cover');
      const rect = editCover.getBoundingClientRect();

      // Map touch coordinates to image pixel coordinates
      const relX = (clientX - rect.left) / rect.width;
      const relY = (clientY - rect.top) / rect.height;

      // Clamp to image bounds
      const cx = Math.max(0, Math.min(eyedropperCanvas.width - 1, Math.floor(relX * eyedropperCanvas.width)));
      const cy = Math.max(0, Math.min(eyedropperCanvas.height - 1, Math.floor(relY * eyedropperCanvas.height)));

      const pixel = eyedropperCtx.getImageData(cx, cy, 1, 1).data;
      eyedropperPickedColor = rgbToHex(pixel[0], pixel[1], pixel[2]);
    }

    function updateEyedropperPreview(clientX, clientY) {
      const preview = document.getElementById('eyedropper-preview');
      if (!preview) return;

      preview.classList.add('visible');
      preview.style.left = clientX + 'px';
      preview.style.top = clientY + 'px';
      preview.style.backgroundColor = eyedropperPickedColor || '#888';
    }

    function applyEyedropperColor(color) {
      const tb = editTextBoxes.find(t => t.id === currentTextBoxId);
      if (!tb) return;

      const textBox = document.getElementById('edit-text-box');
      const staticEl = document.querySelector(`.edit-text-static[data-id="${currentTextBoxId}"]`);

      if (eyedropperMode === 'bg') {
        tb.color = color;
        if (textBox.style.display !== 'none') {
          textBox.style.backgroundColor = color;
          textBox.classList.remove('no-bg');
          if (!tb.textColor) {
            textBox.style.color = isLightColor(color) ? '#1a1a1a' : '#ffffff';
          }
        }
        if (staticEl) {
          staticEl.style.backgroundColor = color;
          staticEl.classList.remove('no-bg');
          if (!tb.textColor) {
            staticEl.style.color = isLightColor(color) ? '#1a1a1a' : '#ffffff';
          }
        }
      } else if (eyedropperMode === 'text') {
        tb.textColor = color;
        if (textBox.style.display !== 'none') {
          textBox.style.color = color;
        }
        if (staticEl) {
          staticEl.style.color = color;
        }
      }
      updateToolbarState();
    }

    function deactivateTouchEyedropper() {
      eyedropperActive = false;
      eyedropperPickedColor = null;
      eyedropperCanvas = null;
      eyedropperCtx = null;

      const overlay = document.getElementById('eyedropper-overlay');
      const preview = document.getElementById('eyedropper-preview');
      const eyedropperBtn = document.getElementById('eyedropper-btn');

      overlay.classList.remove('active');
      if (preview) preview.classList.remove('visible');
      if (eyedropperBtn) eyedropperBtn.classList.remove('active');

      overlay.removeEventListener('touchstart', eyedropperTouchStart);
      overlay.removeEventListener('touchmove', eyedropperTouchMove);
      overlay.removeEventListener('touchend', eyedropperTouchEnd);
      overlay.removeEventListener('touchcancel', eyedropperTouchCancel);
      overlay.removeEventListener('mousedown', eyedropperMouseDown);
      overlay.removeEventListener('mousemove', eyedropperMouseMove);
      overlay.removeEventListener('mouseup', eyedropperMouseUp);
      eyedropperMouseIsDown = false;
    }

    // Text box dragging (touch)
    function handleEditTextBoxTouchStart(e) {
      if (currentView !== 'edit') return;
      if (isEditing) return;

      const touch = e.touches[0];
      const textBox = document.getElementById('edit-text-box');
      const textInput = document.getElementById('edit-text-box-input');

      coverWrapRect = document.getElementById('edit-cover-wrap').getBoundingClientRect();
      textBoxStartX = textBoxX;
      textBoxStartY = textBoxY;
      dragStartX = touch.clientX;
      dragStartY = touch.clientY;

      // Start long press timer for drag
      longPressTimer = setTimeout(() => {
        isDragging = true;
        textBox.style.opacity = '0.8';
        // Show trash if text box has content
        if (textInput.value.trim()) {
          document.getElementById('edit-trash').classList.add('visible');
        }
      }, 150);
    }

    function handleEditTextBoxTouchMove(e) {
      if (currentView !== 'edit') return;

      const textInput = document.getElementById('edit-text-box-input');

      // If moved, clear long press and start dragging immediately
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
        isDragging = true;
        document.getElementById('edit-text-box').style.opacity = '0.8';
        // Show trash if text box has content
        if (textInput.value.trim()) {
          document.getElementById('edit-trash').classList.add('visible');
        }
      }

      if (!isDragging) return;
      e.preventDefault();

      const touch = e.touches[0];
      const deltaX = touch.clientX - dragStartX;
      const deltaY = touch.clientY - dragStartY;

      let newX = textBoxStartX + deltaX;
      let newY = textBoxStartY + deltaY;

      // Constrain to cover area
      const textBox = document.getElementById('edit-text-box');
      const maxX = coverWrapRect.width - textBox.offsetWidth - 10;
      const maxY = coverWrapRect.height - textBox.offsetHeight - 80;
      newX = Math.max(10, Math.min(newX, maxX));
      newY = Math.max(10, Math.min(newY, maxY));

      textBoxX = newX;
      textBoxY = newY;
      textBox.style.left = textBoxX + 'px';
      textBox.style.top = textBoxY + 'px';

      // Check if over trash
      checkTrashHover(touch.clientX, touch.clientY);
    }

    function handleEditTextBoxTouchEnd(e) {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }

      const textBox = document.getElementById('edit-text-box');
      const trash = document.getElementById('edit-trash');

      // Check if dropped on trash
      if (isDragging && trash.classList.contains('active')) {
        // Delete the text box
        deleteTextBox();
      }

      textBox.style.opacity = '1';
      trash.classList.remove('visible', 'active');

      if (!isDragging && !isEditing) {
        // It was a tap, enter edit mode
        showEditInputMode();
        // preventScroll: see iOS cover-jump fix layer 2 in handleEditCoverTap
        document.getElementById('edit-text-box-input').focus({ preventScroll: true });
      }

      isDragging = false;
      coverWrapRect = null;
    }

    // Text box dragging (mouse)
    function handleEditTextBoxMouseDown(e) {
      if (currentView !== 'edit') return;
      if (isEditing) return;
      e.preventDefault();

      const textInput = document.getElementById('edit-text-box-input');

      coverWrapRect = document.getElementById('edit-cover-wrap').getBoundingClientRect();
      textBoxStartX = textBoxX;
      textBoxStartY = textBoxY;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      isDragging = true;
      document.getElementById('edit-text-box').style.opacity = '0.8';

      // Show trash if text box has content
      if (textInput.value.trim()) {
        document.getElementById('edit-trash').classList.add('visible');
      }
    }

    function handleEditTextBoxMouseMove(e) {
      if (!isDragging || !coverWrapRect) return;

      const deltaX = e.clientX - dragStartX;
      const deltaY = e.clientY - dragStartY;

      let newX = textBoxStartX + deltaX;
      let newY = textBoxStartY + deltaY;

      // Check if we're dragging a static text box or the active one
      const staticEl = document.querySelector(`.edit-text-static[data-id="${currentTextBoxId}"]`);
      const textBox = document.getElementById('edit-text-box');
      const el = staticEl || textBox;

      const maxX = coverWrapRect.width - el.offsetWidth - 10;
      const maxY = coverWrapRect.height - el.offsetHeight - 80;
      newX = Math.max(10, Math.min(newX, maxX));
      newY = Math.max(10, Math.min(newY, maxY));

      textBoxX = newX;
      textBoxY = newY;
      el.style.left = textBoxX + 'px';
      el.style.top = textBoxY + 'px';

      // Update position in array for static text boxes
      if (staticEl && currentTextBoxId !== null) {
        const tb = editTextBoxes.find(t => t.id === currentTextBoxId);
        if (tb) {
          tb.x = newX;
          tb.y = newY;
        }
      }

      // Check if over trash
      checkTrashHover(e.clientX, e.clientY);
    }

    function handleEditTextBoxMouseUp(e) {
      const textBox = document.getElementById('edit-text-box');
      const trash = document.getElementById('edit-trash');
      const staticEl = document.querySelector(`.edit-text-static[data-id="${currentTextBoxId}"]`);

      // Check if dropped on trash
      if (isDragging && trash.classList.contains('active')) {
        if (staticEl) {
          // Delete static text box
          editTextBoxes = editTextBoxes.filter(tb => tb.id !== currentTextBoxId);
          staticEl.remove();
        } else {
          deleteTextBox();
        }
      }

      if (isDragging) {
        if (staticEl) {
          staticEl.style.opacity = '1';
        } else {
          textBox.style.opacity = '1';
        }
      }

      trash.classList.remove('visible', 'active');
      isDragging = false;
      coverWrapRect = null;
    }

    function checkTrashHover(clientX, clientY) {
      const trash = document.getElementById('edit-trash');
      const trashRect = trash.getBoundingClientRect();

      // Check if pointer is over trash
      const isOverTrash = clientX >= trashRect.left &&
                          clientX <= trashRect.right &&
                          clientY >= trashRect.top &&
                          clientY <= trashRect.bottom;

      if (isOverTrash) {
        trash.classList.add('active');
      } else {
        trash.classList.remove('active');
      }
    }

    function deleteTextBox() {
      const textBox = document.getElementById('edit-text-box');
      const textInput = document.getElementById('edit-text-box-input');
      const textDisplay = document.getElementById('edit-text-box-display');

      textInput.value = '';
      textDisplay.textContent = '';
      textBox.style.display = 'none';
      isEditing = false;
    }

    // Save button - save and show Book View
    function handleSave() {
      if (!selectedBook) return;

      // Save any active text box to the array first
      const textBox = document.getElementById('edit-text-box');
      if (textBox.style.display !== 'none') {
        saveCurrentTextBoxToArray();
      }

      // Hide color toolbar
      hideColorToolbar();

      // Convert editTextBoxes to the storage format
      const textBoxes = editTextBoxes.map(tb => ({
        text: tb.text,
        x: Math.round(tb.x),
        y: Math.round(tb.y),
        color: tb.color || '#ffffff',
        textColor: tb.textColor || null,
        fontStyle: tb.fontStyle !== undefined ? tb.fontStyle : 0,
        fontSize: tb.fontSize || DEFAULT_FONT_SIZE
      }));

      // For backward compatibility, also set reflection to first text box
      const reflection = textBoxes.length > 0 ? textBoxes[0].text : '';

      const updatedBook = updateBook(selectedBook.id, {
        textBoxes,
        reflection,
        textBoxColor: textBoxes.length > 0 ? textBoxes[0].color : '#ffffff',
        textBoxX: textBoxes.length > 0 ? textBoxes[0].x : 0,
        textBoxY: textBoxes.length > 0 ? textBoxes[0].y : 0,
        yearRead: selectedBook.yearRead || new Date().getFullYear().toString()
      });

      // Go to Book View to show the result (no animation)
      showBookView(updatedBook || selectedBook, true, false);
    }

    // Search books (Open Library API + Google Books for Chinese support)
    async function searchBooks() {
      const query = document.getElementById('search-input').value.trim();
      if (!query) return;

      const resultsContainer = document.getElementById('search-results');
      resultsContainer.innerHTML = '<div class="search-message">searching...</div>';

      // Detect if query contains Chinese characters (including Traditional Chinese range)
      const hasChinese = /[\u4e00-\u9fff\u3400-\u4dbf\u3100-\u312F\uF900-\uFAFF]/.test(query);

      // Helper to parse Google Books results
      const parseGoogleBooks = (data) => {
        if (!data.items || data.items.length === 0) return [];
        return data.items.map(item => {
          const info = item.volumeInfo;
          let summary = info.description || '';
          if (summary.length > 300) {
            summary = summary.substring(0, 300).trim() + '...';
          }
          return {
            title: info.title || 'Unknown Title',
            author: info.authors?.join(', ') || 'Unknown Author',
            thumbUrl: info.imageLinks?.thumbnail?.replace('http:', 'https:') || '',
            coverUrl: info.imageLinks?.thumbnail?.replace('http:', 'https:').replace('zoom=1', 'zoom=2') || '',
            summary: summary
          };
        });
      };

      try {
        let results = [];

        if (hasChinese) {
          // Search Google Books without language restriction for better Traditional Chinese coverage
          const [googleResponse1, googleResponse2] = await Promise.all([
            fetch(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=20&printType=books`),
            fetch(`https://www.googleapis.com/books/v1/volumes?q=intitle:${encodeURIComponent(query)}&maxResults=15&printType=books`)
          ]);

          const [googleData1, googleData2] = await Promise.all([
            googleResponse1.json(),
            googleResponse2.json()
          ]);

          results = [...parseGoogleBooks(googleData1), ...parseGoogleBooks(googleData2)];
        } else {
          // For non-Chinese queries, search Google Books as well
          const googleResponse = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=10&printType=books`);
          const googleData = await googleResponse.json();
          results = parseGoogleBooks(googleData);
        }

        // Also search Open Library (works well for English and some Chinese)
        const openLibResponse = await fetch(`https://openlibrary.org/search.json?q=${encodeURIComponent(query)}&limit=10`);
        const openLibData = await openLibResponse.json();

        if (openLibData.docs && openLibData.docs.length > 0) {
          const openLibResults = openLibData.docs.map(doc => ({
            title: doc.title || 'Unknown Title',
            author: doc.author_name?.join(', ') || 'Unknown Author',
            thumbUrl: doc.cover_i ? `https://covers.openlibrary.org/b/id/${doc.cover_i}-M.jpg` : '',
            coverUrl: doc.cover_i ? `https://covers.openlibrary.org/b/id/${doc.cover_i}-L.jpg` : '',
            summary: doc.first_sentence?.join(' ') || '',
            openLibraryKey: doc.key || ''
          }));

          // Merge results, prioritizing Chinese results for Chinese queries
          if (hasChinese) {
            results = [...results, ...openLibResults];
          } else {
            results = [...openLibResults, ...results];
          }
        }

        // Remove duplicates by title (rough match)
        const seen = new Set();
        results = results.filter(r => {
          const key = r.title.toLowerCase().substring(0, 20);
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).slice(0, 20);

        if (results.length === 0) {
          resultsContainer.innerHTML = '<div class="search-message">no books found. try a different search.</div>';
          return;
        }

        resultsContainer.innerHTML = results.map(book => {
          const thumbUrl = book.thumbUrl || 'https://via.placeholder.com/50x75/f0f0f0/999?text=No+Cover';

          return `
            <div class="result-item" onclick="addBookFromSearch(${JSON.stringify({
              title: book.title,
              author: book.author,
              coverUrl: book.coverUrl,
              summary: book.summary || ''
            }).replace(/"/g, '&quot;')})">
              <img src="${thumbUrl}" alt="${book.title}" class="result-cover" onerror="this.src='https://via.placeholder.com/50x75/f0f0f0/999?text=No+Cover'">
              <div class="result-info">
                <div class="result-title">${book.title}</div>
                <div class="result-author">${book.author}</div>
              </div>
            </div>
          `;
        }).join('');
      } catch (error) {
        resultsContainer.innerHTML = '<div class="search-message">error searching. please try again.</div>';
        console.error('Search error:', error);
      }
    }

    function handleSearchKeypress(event) {
      if (event.key === 'Enter') searchBooks();
    }

    function addBookFromSearch(bookData) {
      const book = addBook({
        title: bookData.title,
        author: bookData.author,
        coverUrl: bookData.coverUrl || '',
        summary: bookData.summary || ''
      });
      showEditView(book);
    }

    // Manual form
    function handleManualSubmit() {
      const title = document.getElementById('manual-title').value.trim();
      const author = document.getElementById('manual-author').value.trim();
      const yearRead = document.getElementById('manual-year').value.trim();
      const coverUrl = document.getElementById('cover-url-input').value.trim();

      if (!title) {
        alert('please enter a book title.');
        return;
      }

      // Use uploaded image, then URL, then placeholder
      let finalCoverUrl = uploadedCoverBase64 || coverUrl || 'https://via.placeholder.com/128x192/f0f0f0/999?text=No+Cover';

      const book = addBook({
        title,
        author: author || 'Unknown Author',
        coverUrl: finalCoverUrl,
        yearRead: yearRead || new Date().getFullYear().toString()
      });

      showEditView(book);
    }

    function handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        uploadedCoverBase64 = e.target.result;
        const container = document.getElementById('cover-preview-container');
        container.innerHTML = `<img src="${uploadedCoverBase64}" alt="Cover preview" class="cover-preview">`;
        container.classList.remove('cover-placeholder');
        // Clear URL input when image is uploaded
        document.getElementById('cover-url-input').value = '';
      };
      reader.readAsDataURL(file);
    }

    function handleCoverUrlInput(event) {
      const url = event.target.value.trim();
      if (!url) return;

      // Clear uploaded image when URL is entered
      uploadedCoverBase64 = null;
      const container = document.getElementById('cover-preview-container');
      container.innerHTML = `<img src="${url}" alt="Cover preview" class="cover-preview" onerror="this.parentElement.innerHTML='<span class=\\'cover-placeholder-icon\\'>+</span><span class=\\'cover-placeholder-text\\'>upload</span>';this.parentElement.classList.add('cover-placeholder');">`;
      container.classList.remove('cover-placeholder');
    }

    function resetAddForm() {
      document.getElementById('search-input').value = '';
      document.getElementById('search-results').innerHTML = '<div class="search-message">search for a book above</div>';
      document.getElementById('manual-title').value = '';
      document.getElementById('manual-author').value = '';
      document.getElementById('manual-year').value = '';
      document.getElementById('cover-url-input').value = '';
      uploadedCoverBase64 = null;

      const container = document.getElementById('cover-preview-container');
      container.innerHTML = '<span class="cover-placeholder-icon">+</span><span class="cover-placeholder-text">upload</span>';
      container.classList.add('cover-placeholder');

      switchTab('search');
    }


    // Delete modal
    function showDeleteModal() {
      document.getElementById('delete-modal').classList.add('active');
    }

    function hideDeleteModal() {
      document.getElementById('delete-modal').classList.remove('active');
    }

    function confirmDelete() {
      if (!selectedBook) return;
      deleteBook(selectedBook.id);
      hideDeleteModal();
      showHomeView();
    }

    // ==========================================
    // PWA Service Worker Registration
    // ==========================================

    // Register service worker for offline support
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js')
          .then((registration) => {
            console.log('Service Worker registered:', registration.scope);

            // Check for updates periodically
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // New version available - you could show an update prompt here
                  console.log('New version available! Refresh to update.');
                }
              });
            });
          })
          .catch((error) => {
            console.log('Service Worker registration failed:', error);
          });
      });
    }
  </script>
</body>
</html>
